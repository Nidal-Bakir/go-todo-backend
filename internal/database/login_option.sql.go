// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: login_option.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewLoginOption = `-- name: CreateNewLoginOption :one
INSERT INTO login_option(
        login_method,
        access_key,
        hashed_pass,
        pass_salt,
        user_id
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, login_method, access_key, hashed_pass, pass_salt, verified_at, created_at, updated_at, deleted_at, user_id
`

type CreateNewLoginOptionParams struct {
	LoginMethod string      `json:"login_method"`
	AccessKey   string      `json:"access_key"`
	HashedPass  pgtype.Text `json:"hashed_pass"`
	PassSalt    pgtype.Text `json:"pass_salt"`
	UserID      int32       `json:"user_id"`
}

// CreateNewLoginOption
//
//	INSERT INTO login_option(
//	        login_method,
//	        access_key,
//	        hashed_pass,
//	        pass_salt,
//	        user_id
//	    )
//	VALUES ($1, $2, $3, $4, $5)
//	RETURNING id, login_method, access_key, hashed_pass, pass_salt, verified_at, created_at, updated_at, deleted_at, user_id
func (q *Queries) CreateNewLoginOption(ctx context.Context, arg CreateNewLoginOptionParams) (LoginOption, error) {
	row := q.db.QueryRow(ctx, createNewLoginOption,
		arg.LoginMethod,
		arg.AccessKey,
		arg.HashedPass,
		arg.PassSalt,
		arg.UserID,
	)
	var i LoginOption
	err := row.Scan(
		&i.ID,
		&i.LoginMethod,
		&i.AccessKey,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const getActiveLoginOption = `-- name: GetActiveLoginOption :one
SELECT id, login_method, access_key, hashed_pass, pass_salt, verified_at, created_at, updated_at, deleted_at, user_id
FROM login_option
WHERE login_method = $1
    AND access_key = $2
    AND verified_at IS NOT NULL
    AND deleted_at IS NULL
LIMIT 1
`

type GetActiveLoginOptionParams struct {
	LoginMethod string `json:"login_method"`
	AccessKey   string `json:"access_key"`
}

// GetActiveLoginOption
//
//	SELECT id, login_method, access_key, hashed_pass, pass_salt, verified_at, created_at, updated_at, deleted_at, user_id
//	FROM login_option
//	WHERE login_method = $1
//	    AND access_key = $2
//	    AND verified_at IS NOT NULL
//	    AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetActiveLoginOption(ctx context.Context, arg GetActiveLoginOptionParams) (LoginOption, error) {
	row := q.db.QueryRow(ctx, getActiveLoginOption, arg.LoginMethod, arg.AccessKey)
	var i LoginOption
	err := row.Scan(
		&i.ID,
		&i.LoginMethod,
		&i.AccessKey,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const getActiveLoginOptionWithUser = `-- name: GetActiveLoginOptionWithUser :one
SELECT lo.id, login_method, access_key, hashed_pass, pass_salt, verified_at, lo.created_at, lo.updated_at, lo.deleted_at, user_id, u.id, username, profile_image, first_name, middle_name, last_name, u.created_at, u.updated_at, blocked_at, u.deleted_at, role_id
FROM login_option AS lo
    JOIN users AS u ON lo.user_id = u.id
WHERE lo.login_method = $1
    AND lo.access_key = $2
    AND lo.verified_at IS NOT NULL
    AND lo.deleted_at IS NULL
    AND u.deleted_at IS NULL
LIMIT 1
`

type GetActiveLoginOptionWithUserParams struct {
	LoginMethod string `json:"login_method"`
	AccessKey   string `json:"access_key"`
}

type GetActiveLoginOptionWithUserRow struct {
	ID           int32              `json:"id"`
	LoginMethod  string             `json:"login_method"`
	AccessKey    string             `json:"access_key"`
	HashedPass   pgtype.Text        `json:"hashed_pass"`
	PassSalt     pgtype.Text        `json:"pass_salt"`
	VerifiedAt   pgtype.Timestamptz `json:"verified_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	UserID       int32              `json:"user_id"`
	ID_2         int32              `json:"id_2"`
	Username     string             `json:"username"`
	ProfileImage pgtype.Text        `json:"profile_image"`
	FirstName    string             `json:"first_name"`
	MiddleName   pgtype.Text        `json:"middle_name"`
	LastName     pgtype.Text        `json:"last_name"`
	CreatedAt_2  pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2  pgtype.Timestamptz `json:"updated_at_2"`
	BlockedAt    pgtype.Timestamptz `json:"blocked_at"`
	DeletedAt_2  pgtype.Timestamptz `json:"deleted_at_2"`
	RoleID       pgtype.Int4        `json:"role_id"`
}

// GetActiveLoginOptionWithUser
//
//	SELECT lo.id, login_method, access_key, hashed_pass, pass_salt, verified_at, lo.created_at, lo.updated_at, lo.deleted_at, user_id, u.id, username, profile_image, first_name, middle_name, last_name, u.created_at, u.updated_at, blocked_at, u.deleted_at, role_id
//	FROM login_option AS lo
//	    JOIN users AS u ON lo.user_id = u.id
//	WHERE lo.login_method = $1
//	    AND lo.access_key = $2
//	    AND lo.verified_at IS NOT NULL
//	    AND lo.deleted_at IS NULL
//	    AND u.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetActiveLoginOptionWithUser(ctx context.Context, arg GetActiveLoginOptionWithUserParams) (GetActiveLoginOptionWithUserRow, error) {
	row := q.db.QueryRow(ctx, getActiveLoginOptionWithUser, arg.LoginMethod, arg.AccessKey)
	var i GetActiveLoginOptionWithUserRow
	err := row.Scan(
		&i.ID,
		&i.LoginMethod,
		&i.AccessKey,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.ID_2,
		&i.Username,
		&i.ProfileImage,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.BlockedAt,
		&i.DeletedAt_2,
		&i.RoleID,
	)
	return i, err
}

const markUserLoginOptionAsVerified = `-- name: MarkUserLoginOptionAsVerified :exec
UPDATE login_option
SET verified_at = NOW()
WHERE id = $1
`

// MarkUserLoginOptionAsVerified
//
//	UPDATE login_option
//	SET verified_at = NOW()
//	WHERE id = $1
func (q *Queries) MarkUserLoginOptionAsVerified(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, markUserLoginOptionAsVerified, id)
	return err
}

const setPasswordForUserLoginOption = `-- name: SetPasswordForUserLoginOption :exec
UPDATE login_option
SET hashed_pass = $2,
    pass_salt = $3
WHERE id = $1
`

type SetPasswordForUserLoginOptionParams struct {
	ID         int32       `json:"id"`
	HashedPass pgtype.Text `json:"hashed_pass"`
	PassSalt   pgtype.Text `json:"pass_salt"`
}

// SetPasswordForUserLoginOption
//
//	UPDATE login_option
//	SET hashed_pass = $2,
//	    pass_salt = $3
//	WHERE id = $1
func (q *Queries) SetPasswordForUserLoginOption(ctx context.Context, arg SetPasswordForUserLoginOptionParams) error {
	_, err := q.db.Exec(ctx, setPasswordForUserLoginOption, arg.ID, arg.HashedPass, arg.PassSalt)
	return err
}

const softDeleteUserLoginOption = `-- name: SoftDeleteUserLoginOption :exec
UPDATE login_option
SET deleted_at = NOW()
WHERE id = $1
`

// SoftDeleteUserLoginOption
//
//	UPDATE login_option
//	SET deleted_at = NOW()
//	WHERE id = $1
func (q *Queries) SoftDeleteUserLoginOption(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteUserLoginOption, id)
	return err
}
