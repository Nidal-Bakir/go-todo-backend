// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: login_option.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewLoginOption = `-- name: CreateNewLoginOption :one
INSERT INTO login_option(
        login_method,
        access_key,
        hashed_pass,
        pass_salt,
        user_id
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, login_method, access_key, hashed_pass, pass_salt, verified_at, created_at, updated_at, deleted_at, user_id
`

type CreateNewLoginOptionParams struct {
	LoginMethod string      `json:"login_method"`
	AccessKey   string      `json:"access_key"`
	HashedPass  pgtype.Text `json:"hashed_pass"`
	PassSalt    pgtype.Text `json:"pass_salt"`
	UserID      int32       `json:"user_id"`
}

// CreateNewLoginOption
//
//	INSERT INTO login_option(
//	        login_method,
//	        access_key,
//	        hashed_pass,
//	        pass_salt,
//	        user_id
//	    )
//	VALUES ($1, $2, $3, $4, $5)
//	RETURNING id, login_method, access_key, hashed_pass, pass_salt, verified_at, created_at, updated_at, deleted_at, user_id
func (q *Queries) CreateNewLoginOption(ctx context.Context, arg CreateNewLoginOptionParams) (LoginOption, error) {
	row := q.db.QueryRow(ctx, createNewLoginOption,
		arg.LoginMethod,
		arg.AccessKey,
		arg.HashedPass,
		arg.PassSalt,
		arg.UserID,
	)
	var i LoginOption
	err := row.Scan(
		&i.ID,
		&i.LoginMethod,
		&i.AccessKey,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const markUserLoginOptionAsVerified = `-- name: MarkUserLoginOptionAsVerified :exec
UPDATE login_option
SET verified_at = NOW()
WHERE id = $1
`

// MarkUserLoginOptionAsVerified
//
//	UPDATE login_option
//	SET verified_at = NOW()
//	WHERE id = $1
func (q *Queries) MarkUserLoginOptionAsVerified(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, markUserLoginOptionAsVerified, id)
	return err
}

const setPasswordForUserLoginOption = `-- name: SetPasswordForUserLoginOption :exec
UPDATE login_option
SET hashed_pass = $2,
    pass_salt = $3
WHERE id = $1
`

type SetPasswordForUserLoginOptionParams struct {
	ID         int32       `json:"id"`
	HashedPass pgtype.Text `json:"hashed_pass"`
	PassSalt   pgtype.Text `json:"pass_salt"`
}

// SetPasswordForUserLoginOption
//
//	UPDATE login_option
//	SET hashed_pass = $2,
//	    pass_salt = $3
//	WHERE id = $1
func (q *Queries) SetPasswordForUserLoginOption(ctx context.Context, arg SetPasswordForUserLoginOptionParams) error {
	_, err := q.db.Exec(ctx, setPasswordForUserLoginOption, arg.ID, arg.HashedPass, arg.PassSalt)
	return err
}

const softDeleteUserLoginOption = `-- name: SoftDeleteUserLoginOption :exec
UPDATE login_option
SET deleted_at = NOW()
WHERE id = $1
`

// SoftDeleteUserLoginOption
//
//	UPDATE login_option
//	SET deleted_at = NOW()
//	WHERE id = $1
func (q *Queries) SoftDeleteUserLoginOption(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteUserLoginOption, id)
	return err
}
