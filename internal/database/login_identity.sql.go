// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: login_identity.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const loginIdentityChangePasswordLoginIdentityByUserId = `-- name: LoginIdentityChangePasswordLoginIdentityByUserId :exec
UPDATE password_login_identity pli
SET
    hashed_pass = $2,
    pass_salt = $3
FROM active_login_identity li
WHERE pli.login_identity_id = li.id
  AND li.user_id = $1
`

type LoginIdentityChangePasswordLoginIdentityByUserIdParams struct {
	UserID     int32  `json:"user_id"`
	HashedPass string `json:"hashed_pass"`
	PassSalt   string `json:"pass_salt"`
}

// LoginIdentityChangePasswordLoginIdentityByUserId
//
//	UPDATE password_login_identity pli
//	SET
//	    hashed_pass = $2,
//	    pass_salt = $3
//	FROM active_login_identity li
//	WHERE pli.login_identity_id = li.id
//	  AND li.user_id = $1
func (q *Queries) LoginIdentityChangePasswordLoginIdentityByUserId(ctx context.Context, arg LoginIdentityChangePasswordLoginIdentityByUserIdParams) error {
	_, err := q.db.Exec(ctx, loginIdentityChangePasswordLoginIdentityByUserId, arg.UserID, arg.HashedPass, arg.PassSalt)
	return err
}

const loginIdentityCreateNewPasswordLoginIdentity = `-- name: LoginIdentityCreateNewPasswordLoginIdentity :one
WITH new_identity AS (
 INSERT INTO login_identity (user_id, identity_type)
 VALUES ($1, $2)
 RETURNING id
)
INSERT INTO password_login_identity (
    login_identity_id,
    email,
    phone,
    hashed_pass,
    pass_salt,
    verified_at
)
VALUES (
    (SELECT id FROM new_identity),
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING id AS password_login_identity_id, (SELECT id AS login_identity_id FROM new_identity)
`

type LoginIdentityCreateNewPasswordLoginIdentityParams struct {
	UserID       int32              `json:"user_id"`
	IdentityType string             `json:"identity_type"`
	Email        pgtype.Text        `json:"email"`
	Phone        pgtype.Text        `json:"phone"`
	HashedPass   string             `json:"hashed_pass"`
	PassSalt     string             `json:"pass_salt"`
	VerifiedAt   pgtype.Timestamptz `json:"verified_at"`
}

type LoginIdentityCreateNewPasswordLoginIdentityRow struct {
	PasswordLoginIdentityID int32 `json:"password_login_identity_id"`
	LoginIdentityID         int32 `json:"login_identity_id"`
}

// LoginIdentityCreateNewPasswordLoginIdentity
//
//	WITH new_identity AS (
//	 INSERT INTO login_identity (user_id, identity_type)
//	 VALUES ($1, $2)
//	 RETURNING id
//	)
//	INSERT INTO password_login_identity (
//	    login_identity_id,
//	    email,
//	    phone,
//	    hashed_pass,
//	    pass_salt,
//	    verified_at
//	)
//	VALUES (
//	    (SELECT id FROM new_identity),
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7
//	)
//	RETURNING id AS password_login_identity_id, (SELECT id AS login_identity_id FROM new_identity)
func (q *Queries) LoginIdentityCreateNewPasswordLoginIdentity(ctx context.Context, arg LoginIdentityCreateNewPasswordLoginIdentityParams) (LoginIdentityCreateNewPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityCreateNewPasswordLoginIdentity,
		arg.UserID,
		arg.IdentityType,
		arg.Email,
		arg.Phone,
		arg.HashedPass,
		arg.PassSalt,
		arg.VerifiedAt,
	)
	var i LoginIdentityCreateNewPasswordLoginIdentityRow
	err := row.Scan(&i.PasswordLoginIdentityID, &i.LoginIdentityID)
	return i, err
}

const loginIdentityGetAllByUserId = `-- name: LoginIdentityGetAllByUserId :many
SELECT
  li.id AS login_identity_id,
  li.user_id AS login_identity_user_id,
  li.identity_type AS login_identity_identity_type,
  li.is_primary AS login_identity_is_primary,
  li.last_used_at AS login_identity_last_used_at,

  -- Password-based
  pli.id AS password_id,
  pli.email  AS password_email,
  pli.phone  AS password_phone,
  pli.hashed_pass  AS password_hashed_pass,
  pli.pass_salt  AS password_pass_salt,
  pli.verified_at AS password_verified_at,

  -- Guest-based
  gli.id AS guest_id,
  gli.device_id AS guest_device_id,

  -- OIDC-based
  oud.id AS oidc_data_id,
  oud.sub AS oidc_data_sub,
  oud.email AS oidc_data_email,
  oud.iss AS oidc_data_issuer,
  oud.aud AS oidc_data_audience,
  oud.given_name AS oidc_data_given_name,
  oud.family_name AS oidc_data_family_name,
  oud.name AS oidc_data_name,
  oud.picture AS oidc_data_picture,
  
  -- oauth_provider
  op.name AS oauth_provider_name
  
FROM active_login_identity AS li
LEFT JOIN active_password_login_identity AS pli
  ON li.id = pli.login_identity_id
LEFT JOIN active_guest_login_identity AS gli
  ON li.id = gli.login_identity_id
LEFT JOIN active_oidc_login_identity AS oli
  ON li.id = oli.login_identity_id
LEFT JOIN active_oidc_user_integration_data AS oud
  ON oli.oidc_user_integration_data_id = oud.id
LEFT JOIN user_integration AS ui
  ON oud.user_integration_id = ui.id
LEFT JOIN oauth_integration AS oi
  ON ui.oauth_integration_id = oi.id
LEFT JOIN oauth_connection AS oc
  ON oi.oauth_connection_id = oc.id
LEFT JOIN oauth_provider AS op
  ON oc.provider_id = op.id
  
WHERE li.user_id = $1
ORDER BY li.is_primary DESC, li.last_used_at DESC
`

type LoginIdentityGetAllByUserIdRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	LoginIdentityUserID       int32              `json:"login_identity_user_id"`
	LoginIdentityIdentityType string             `json:"login_identity_identity_type"`
	LoginIdentityIsPrimary    pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt   pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordID                pgtype.Int4        `json:"password_id"`
	PasswordEmail             pgtype.Text        `json:"password_email"`
	PasswordPhone             pgtype.Text        `json:"password_phone"`
	PasswordHashedPass        pgtype.Text        `json:"password_hashed_pass"`
	PasswordPassSalt          pgtype.Text        `json:"password_pass_salt"`
	PasswordVerifiedAt        pgtype.Timestamptz `json:"password_verified_at"`
	GuestID                   pgtype.Int4        `json:"guest_id"`
	GuestDeviceID             pgtype.Text        `json:"guest_device_id"`
	OidcDataID                pgtype.Int4        `json:"oidc_data_id"`
	OidcDataSub               pgtype.Text        `json:"oidc_data_sub"`
	OidcDataEmail             pgtype.Text        `json:"oidc_data_email"`
	OidcDataIssuer            pgtype.Text        `json:"oidc_data_issuer"`
	OidcDataAudience          pgtype.Text        `json:"oidc_data_audience"`
	OidcDataGivenName         pgtype.Text        `json:"oidc_data_given_name"`
	OidcDataFamilyName        pgtype.Text        `json:"oidc_data_family_name"`
	OidcDataName              pgtype.Text        `json:"oidc_data_name"`
	OidcDataPicture           pgtype.Text        `json:"oidc_data_picture"`
	OauthProviderName         pgtype.Text        `json:"oauth_provider_name"`
}

// LoginIdentityGetAllByUserId
//
//	SELECT
//	  li.id AS login_identity_id,
//	  li.user_id AS login_identity_user_id,
//	  li.identity_type AS login_identity_identity_type,
//	  li.is_primary AS login_identity_is_primary,
//	  li.last_used_at AS login_identity_last_used_at,
//
//	  -- Password-based
//	  pli.id AS password_id,
//	  pli.email  AS password_email,
//	  pli.phone  AS password_phone,
//	  pli.hashed_pass  AS password_hashed_pass,
//	  pli.pass_salt  AS password_pass_salt,
//	  pli.verified_at AS password_verified_at,
//
//	  -- Guest-based
//	  gli.id AS guest_id,
//	  gli.device_id AS guest_device_id,
//
//	  -- OIDC-based
//	  oud.id AS oidc_data_id,
//	  oud.sub AS oidc_data_sub,
//	  oud.email AS oidc_data_email,
//	  oud.iss AS oidc_data_issuer,
//	  oud.aud AS oidc_data_audience,
//	  oud.given_name AS oidc_data_given_name,
//	  oud.family_name AS oidc_data_family_name,
//	  oud.name AS oidc_data_name,
//	  oud.picture AS oidc_data_picture,
//
//	  -- oauth_provider
//	  op.name AS oauth_provider_name
//
//	FROM active_login_identity AS li
//	LEFT JOIN active_password_login_identity AS pli
//	  ON li.id = pli.login_identity_id
//	LEFT JOIN active_guest_login_identity AS gli
//	  ON li.id = gli.login_identity_id
//	LEFT JOIN active_oidc_login_identity AS oli
//	  ON li.id = oli.login_identity_id
//	LEFT JOIN active_oidc_user_integration_data AS oud
//	  ON oli.oidc_user_integration_data_id = oud.id
//	LEFT JOIN user_integration AS ui
//	  ON oud.user_integration_id = ui.id
//	LEFT JOIN oauth_integration AS oi
//	  ON ui.oauth_integration_id = oi.id
//	LEFT JOIN oauth_connection AS oc
//	  ON oi.oauth_connection_id = oc.id
//	LEFT JOIN oauth_provider AS op
//	  ON oc.provider_id = op.id
//
//	WHERE li.user_id = $1
//	ORDER BY li.is_primary DESC, li.last_used_at DESC
func (q *Queries) LoginIdentityGetAllByUserId(ctx context.Context, userID int32) ([]LoginIdentityGetAllByUserIdRow, error) {
	rows, err := q.db.Query(ctx, loginIdentityGetAllByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginIdentityGetAllByUserIdRow{}
	for rows.Next() {
		var i LoginIdentityGetAllByUserIdRow
		if err := rows.Scan(
			&i.LoginIdentityID,
			&i.LoginIdentityUserID,
			&i.LoginIdentityIdentityType,
			&i.LoginIdentityIsPrimary,
			&i.LoginIdentityLastUsedAt,
			&i.PasswordID,
			&i.PasswordEmail,
			&i.PasswordPhone,
			&i.PasswordHashedPass,
			&i.PasswordPassSalt,
			&i.PasswordVerifiedAt,
			&i.GuestID,
			&i.GuestDeviceID,
			&i.OidcDataID,
			&i.OidcDataSub,
			&i.OidcDataEmail,
			&i.OidcDataIssuer,
			&i.OidcDataAudience,
			&i.OidcDataGivenName,
			&i.OidcDataFamilyName,
			&i.OidcDataName,
			&i.OidcDataPicture,
			&i.OauthProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginIdentityGetAllPasswordLoginIdentitiesByUserId = `-- name: LoginIdentityGetAllPasswordLoginIdentitiesByUserId :many
SELECT
  li.id AS login_identity_id,
  li.user_id AS login_identity_user_id,
  li.identity_type AS login_identity_identity_type,
  li.is_primary AS login_identity_is_primary,
  li.last_used_at AS login_identity_last_used_at,

  -- Password-based
  pli.id AS password_id,
  pli.email  AS password_email,
  pli.phone  AS password_phone,
  pli.hashed_pass  AS password_hashed_pass,
  pli.pass_salt  AS password_pass_salt,
  pli.verified_at AS password_verified_at
FROM active_login_identity AS li
LEFT JOIN active_password_login_identity AS pli
  ON li.id = pli.login_identity_id
WHERE li.user_id = $1
ORDER BY li.is_primary DESC, li.last_used_at DESC
`

type LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	LoginIdentityUserID       int32              `json:"login_identity_user_id"`
	LoginIdentityIdentityType string             `json:"login_identity_identity_type"`
	LoginIdentityIsPrimary    pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt   pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordID                pgtype.Int4        `json:"password_id"`
	PasswordEmail             pgtype.Text        `json:"password_email"`
	PasswordPhone             pgtype.Text        `json:"password_phone"`
	PasswordHashedPass        pgtype.Text        `json:"password_hashed_pass"`
	PasswordPassSalt          pgtype.Text        `json:"password_pass_salt"`
	PasswordVerifiedAt        pgtype.Timestamptz `json:"password_verified_at"`
}

// LoginIdentityGetAllPasswordLoginIdentitiesByUserId
//
//	SELECT
//	  li.id AS login_identity_id,
//	  li.user_id AS login_identity_user_id,
//	  li.identity_type AS login_identity_identity_type,
//	  li.is_primary AS login_identity_is_primary,
//	  li.last_used_at AS login_identity_last_used_at,
//
//	  -- Password-based
//	  pli.id AS password_id,
//	  pli.email  AS password_email,
//	  pli.phone  AS password_phone,
//	  pli.hashed_pass  AS password_hashed_pass,
//	  pli.pass_salt  AS password_pass_salt,
//	  pli.verified_at AS password_verified_at
//	FROM active_login_identity AS li
//	LEFT JOIN active_password_login_identity AS pli
//	  ON li.id = pli.login_identity_id
//	WHERE li.user_id = $1
//	ORDER BY li.is_primary DESC, li.last_used_at DESC
func (q *Queries) LoginIdentityGetAllPasswordLoginIdentitiesByUserId(ctx context.Context, userID int32) ([]LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow, error) {
	rows, err := q.db.Query(ctx, loginIdentityGetAllPasswordLoginIdentitiesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow{}
	for rows.Next() {
		var i LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow
		if err := rows.Scan(
			&i.LoginIdentityID,
			&i.LoginIdentityUserID,
			&i.LoginIdentityIdentityType,
			&i.LoginIdentityIsPrimary,
			&i.LoginIdentityLastUsedAt,
			&i.PasswordID,
			&i.PasswordEmail,
			&i.PasswordPhone,
			&i.PasswordHashedPass,
			&i.PasswordPassSalt,
			&i.PasswordVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginIdentityGetOIDCLoginIdentity = `-- name: LoginIdentityGetOIDCLoginIdentity :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary,
    li.last_used_at,

    oli.id AS oidc_login_identity_id,

    oidc_data.id AS oidc_data_id,
    oidc_data.user_integration_id AS oidc_data_user_integration_id,
    oidc_data.sub AS oidc_data_sub,
    oidc_data.email AS oidc_data_email,
    oidc_data.iss AS oidc_data_iss,
    oidc_data.aud AS oidc_data_aud,
    oidc_data.given_name AS oidc_data_given_name,
    oidc_data.family_name AS oidc_data_family_name,
    oidc_data.name AS oidc_data_name,
    oidc_data.picture AS oidc_data_picture
FROM active_login_identity AS li
    JOIN active_oidc_login_identity oli
        ON li.id = oli.login_identity_id
    JOIN active_oidc_user_integration_data AS oidc_data
        ON oli.oidc_user_integration_data_id = oidc_data.id
WHERE li.identity_type = 'oidc'
    AND oidc_data.sub = $1::text
LIMIT 1
`

type LoginIdentityGetOIDCLoginIdentityRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	UserID                    int32              `json:"user_id"`
	IdentityType              string             `json:"identity_type"`
	IsPrimary                 pgtype.Bool        `json:"is_primary"`
	LastUsedAt                pgtype.Timestamptz `json:"last_used_at"`
	OidcLoginIdentityID       int32              `json:"oidc_login_identity_id"`
	OidcDataID                int32              `json:"oidc_data_id"`
	OidcDataUserIntegrationID int32              `json:"oidc_data_user_integration_id"`
	OidcDataSub               string             `json:"oidc_data_sub"`
	OidcDataEmail             pgtype.Text        `json:"oidc_data_email"`
	OidcDataIss               string             `json:"oidc_data_iss"`
	OidcDataAud               string             `json:"oidc_data_aud"`
	OidcDataGivenName         pgtype.Text        `json:"oidc_data_given_name"`
	OidcDataFamilyName        pgtype.Text        `json:"oidc_data_family_name"`
	OidcDataName              pgtype.Text        `json:"oidc_data_name"`
	OidcDataPicture           pgtype.Text        `json:"oidc_data_picture"`
}

// LoginIdentityGetOIDCLoginIdentity
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary,
//	    li.last_used_at,
//
//	    oli.id AS oidc_login_identity_id,
//
//	    oidc_data.id AS oidc_data_id,
//	    oidc_data.user_integration_id AS oidc_data_user_integration_id,
//	    oidc_data.sub AS oidc_data_sub,
//	    oidc_data.email AS oidc_data_email,
//	    oidc_data.iss AS oidc_data_iss,
//	    oidc_data.aud AS oidc_data_aud,
//	    oidc_data.given_name AS oidc_data_given_name,
//	    oidc_data.family_name AS oidc_data_family_name,
//	    oidc_data.name AS oidc_data_name,
//	    oidc_data.picture AS oidc_data_picture
//	FROM active_login_identity AS li
//	    JOIN active_oidc_login_identity oli
//	        ON li.id = oli.login_identity_id
//	    JOIN active_oidc_user_integration_data AS oidc_data
//	        ON oli.oidc_user_integration_data_id = oidc_data.id
//	WHERE li.identity_type = 'oidc'
//	    AND oidc_data.sub = $1::text
//	LIMIT 1
func (q *Queries) LoginIdentityGetOIDCLoginIdentity(ctx context.Context, oidcSub string) (LoginIdentityGetOIDCLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetOIDCLoginIdentity, oidcSub)
	var i LoginIdentityGetOIDCLoginIdentityRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.IsPrimary,
		&i.LastUsedAt,
		&i.OidcLoginIdentityID,
		&i.OidcDataID,
		&i.OidcDataUserIntegrationID,
		&i.OidcDataSub,
		&i.OidcDataEmail,
		&i.OidcDataIss,
		&i.OidcDataAud,
		&i.OidcDataGivenName,
		&i.OidcDataFamilyName,
		&i.OidcDataName,
		&i.OidcDataPicture,
	)
	return i, err
}

const loginIdentityGetPasswordLoginIdentity = `-- name: LoginIdentityGetPasswordLoginIdentity :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary AS login_identity_is_primary,
    li.last_used_at AS login_identity_last_used_at,

    pli.id AS password_login_identity_id,
    pli.email ,
    pli.phone,
    pli.hashed_pass,
    pli.pass_salt,
    pli.verified_at
FROM active_login_identity AS li
    JOIN active_password_login_identity pli
        ON li.id = pli.login_identity_id
WHERE li.identity_type = $1::text
    AND (
      ($1::text = 'email' AND pli.email = $2::text)
      OR
      ($1::text = 'phone' AND pli.phone = $2::text)
    )
LIMIT 1
`

type LoginIdentityGetPasswordLoginIdentityParams struct {
	IdentityType  string `json:"identity_type"`
	IdentityValue string `json:"identity_value"`
}

type LoginIdentityGetPasswordLoginIdentityRow struct {
	LoginIdentityID         int32              `json:"login_identity_id"`
	UserID                  int32              `json:"user_id"`
	IdentityType            string             `json:"identity_type"`
	LoginIdentityIsPrimary  pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordLoginIdentityID int32              `json:"password_login_identity_id"`
	Email                   pgtype.Text        `json:"email"`
	Phone                   pgtype.Text        `json:"phone"`
	HashedPass              string             `json:"hashed_pass"`
	PassSalt                string             `json:"pass_salt"`
	VerifiedAt              pgtype.Timestamptz `json:"verified_at"`
}

// LoginIdentityGetPasswordLoginIdentity
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary AS login_identity_is_primary,
//	    li.last_used_at AS login_identity_last_used_at,
//
//	    pli.id AS password_login_identity_id,
//	    pli.email ,
//	    pli.phone,
//	    pli.hashed_pass,
//	    pli.pass_salt,
//	    pli.verified_at
//	FROM active_login_identity AS li
//	    JOIN active_password_login_identity pli
//	        ON li.id = pli.login_identity_id
//	WHERE li.identity_type = $1::text
//	    AND (
//	      ($1::text = 'email' AND pli.email = $2::text)
//	      OR
//	      ($1::text = 'phone' AND pli.phone = $2::text)
//	    )
//	LIMIT 1
func (q *Queries) LoginIdentityGetPasswordLoginIdentity(ctx context.Context, arg LoginIdentityGetPasswordLoginIdentityParams) (LoginIdentityGetPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetPasswordLoginIdentity, arg.IdentityType, arg.IdentityValue)
	var i LoginIdentityGetPasswordLoginIdentityRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.LoginIdentityIsPrimary,
		&i.LoginIdentityLastUsedAt,
		&i.PasswordLoginIdentityID,
		&i.Email,
		&i.Phone,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
	)
	return i, err
}

const loginIdentityGetPasswordLoginIdentityWithUser = `-- name: LoginIdentityGetPasswordLoginIdentityWithUser :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary,
    li.last_used_at,

    pli.id AS password_login_identity_id,
    pli.email,
    pli.phone,
    pli.hashed_pass,
    pli.pass_salt,
    pli.verified_at,
    
    u.id as user_id,
    u.username as user_username,
    u.profile_image as user_profile_image,
    u.first_name as user_first_name,
    u.middle_name as user_middle_name,
    u.last_name as user_last_name,
    u.blocked_at as user_blocked_at,
    u.blocked_until as user_blocked_until,
    u.role_id as user_role_id
FROM not_deleted_users AS u     
    JOIN active_login_identity AS li
        ON u.id = li.user_id
    JOIN active_password_login_identity pli
        ON li.id = pli.login_identity_id
WHERE li.identity_type = $1::text
    AND (
      ($1::text = 'email' AND pli.email = $2::text)
      OR
      ($1::text = 'phone' AND pli.phone = $2::text)
    )
LIMIT 1
`

type LoginIdentityGetPasswordLoginIdentityWithUserParams struct {
	IdentityType  string `json:"identity_type"`
	IdentityValue string `json:"identity_value"`
}

type LoginIdentityGetPasswordLoginIdentityWithUserRow struct {
	LoginIdentityID         int32              `json:"login_identity_id"`
	UserID                  int32              `json:"user_id"`
	IdentityType            string             `json:"identity_type"`
	IsPrimary               pgtype.Bool        `json:"is_primary"`
	LastUsedAt              pgtype.Timestamptz `json:"last_used_at"`
	PasswordLoginIdentityID int32              `json:"password_login_identity_id"`
	Email                   pgtype.Text        `json:"email"`
	Phone                   pgtype.Text        `json:"phone"`
	HashedPass              string             `json:"hashed_pass"`
	PassSalt                string             `json:"pass_salt"`
	VerifiedAt              pgtype.Timestamptz `json:"verified_at"`
	UserID_2                int32              `json:"user_id_2"`
	UserUsername            string             `json:"user_username"`
	UserProfileImage        pgtype.Text        `json:"user_profile_image"`
	UserFirstName           string             `json:"user_first_name"`
	UserMiddleName          pgtype.Text        `json:"user_middle_name"`
	UserLastName            pgtype.Text        `json:"user_last_name"`
	UserBlockedAt           pgtype.Timestamptz `json:"user_blocked_at"`
	UserBlockedUntil        pgtype.Timestamptz `json:"user_blocked_until"`
	UserRoleID              pgtype.Int4        `json:"user_role_id"`
}

// LoginIdentityGetPasswordLoginIdentityWithUser
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary,
//	    li.last_used_at,
//
//	    pli.id AS password_login_identity_id,
//	    pli.email,
//	    pli.phone,
//	    pli.hashed_pass,
//	    pli.pass_salt,
//	    pli.verified_at,
//
//	    u.id as user_id,
//	    u.username as user_username,
//	    u.profile_image as user_profile_image,
//	    u.first_name as user_first_name,
//	    u.middle_name as user_middle_name,
//	    u.last_name as user_last_name,
//	    u.blocked_at as user_blocked_at,
//	    u.blocked_until as user_blocked_until,
//	    u.role_id as user_role_id
//	FROM not_deleted_users AS u
//	    JOIN active_login_identity AS li
//	        ON u.id = li.user_id
//	    JOIN active_password_login_identity pli
//	        ON li.id = pli.login_identity_id
//	WHERE li.identity_type = $1::text
//	    AND (
//	      ($1::text = 'email' AND pli.email = $2::text)
//	      OR
//	      ($1::text = 'phone' AND pli.phone = $2::text)
//	    )
//	LIMIT 1
func (q *Queries) LoginIdentityGetPasswordLoginIdentityWithUser(ctx context.Context, arg LoginIdentityGetPasswordLoginIdentityWithUserParams) (LoginIdentityGetPasswordLoginIdentityWithUserRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetPasswordLoginIdentityWithUser, arg.IdentityType, arg.IdentityValue)
	var i LoginIdentityGetPasswordLoginIdentityWithUserRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.IsPrimary,
		&i.LastUsedAt,
		&i.PasswordLoginIdentityID,
		&i.Email,
		&i.Phone,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
		&i.UserID_2,
		&i.UserUsername,
		&i.UserProfileImage,
		&i.UserFirstName,
		&i.UserMiddleName,
		&i.UserLastName,
		&i.UserBlockedAt,
		&i.UserBlockedUntil,
		&i.UserRoleID,
	)
	return i, err
}

const loginIdentityIsEmailUsed = `-- name: LoginIdentityIsEmailUsed :one
SELECT COUNT(*) FROM active_password_login_identity WHERE email = $1
`

// LoginIdentityIsEmailUsed
//
//	SELECT COUNT(*) FROM active_password_login_identity WHERE email = $1
func (q *Queries) LoginIdentityIsEmailUsed(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsEmailUsed, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const loginIdentityIsOidcEmailUsed = `-- name: LoginIdentityIsOidcEmailUsed :one
SELECT COUNT(*) FROM active_oidc_user_integration_data
WHERE email = $1
`

// LoginIdentityIsOidcEmailUsed
//
//	SELECT COUNT(*) FROM active_oidc_user_integration_data
//	WHERE email = $1
func (q *Queries) LoginIdentityIsOidcEmailUsed(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsOidcEmailUsed, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const loginIdentityIsPhoneUsed = `-- name: LoginIdentityIsPhoneUsed :one
SELECT COUNT(*) FROM active_password_login_identity WHERE phone = $1
`

// LoginIdentityIsPhoneUsed
//
//	SELECT COUNT(*) FROM active_password_login_identity WHERE phone = $1
func (q *Queries) LoginIdentityIsPhoneUsed(ctx context.Context, phone pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsPhoneUsed, phone)
	var count int64
	err := row.Scan(&count)
	return count, err
}
