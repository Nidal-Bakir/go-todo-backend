// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: login_identity.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const loginIdentityChangePasswordLoginIdentityByUserId = `-- name: LoginIdentityChangePasswordLoginIdentityByUserId :exec
UPDATE password_login_identity pli
SET
    hashed_pass = $2,
    pass_salt = $3
FROM active_login_identity li
WHERE pli.login_identity_id = li.id
  AND li.user_id = $1
`

type LoginIdentityChangePasswordLoginIdentityByUserIdParams struct {
	UserID     int32  `json:"user_id"`
	HashedPass string `json:"hashed_pass"`
	PassSalt   string `json:"pass_salt"`
}

// LoginIdentityChangePasswordLoginIdentityByUserId
//
//	UPDATE password_login_identity pli
//	SET
//	    hashed_pass = $2,
//	    pass_salt = $3
//	FROM active_login_identity li
//	WHERE pli.login_identity_id = li.id
//	  AND li.user_id = $1
func (q *Queries) LoginIdentityChangePasswordLoginIdentityByUserId(ctx context.Context, arg LoginIdentityChangePasswordLoginIdentityByUserIdParams) error {
	_, err := q.db.Exec(ctx, loginIdentityChangePasswordLoginIdentityByUserId, arg.UserID, arg.HashedPass, arg.PassSalt)
	return err
}

const loginIdentityCreateNewPasswordLoginIdentity = `-- name: LoginIdentityCreateNewPasswordLoginIdentity :one
WITH new_identity AS (
 INSERT INTO login_identity (
    user_id,
    identity_type
 )
 VALUES (
    $6::int,
    $7::text
 )
 RETURNING id
)
INSERT INTO password_login_identity (
    login_identity_id,
    email,
    phone,
    hashed_pass,
    pass_salt,
    verified_at
)
VALUES (
    (SELECT id FROM new_identity),
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5::timestamptz
)
RETURNING id AS password_login_identity_id, (SELECT id AS login_identity_id FROM new_identity)
`

type LoginIdentityCreateNewPasswordLoginIdentityParams struct {
	PasswordEmail      pgtype.Text        `json:"password_email"`
	PasswordPhone      pgtype.Text        `json:"password_phone"`
	PasswordHashedPass string             `json:"password_hashed_pass"`
	PasswordPassSalt   string             `json:"password_pass_salt"`
	PasswordVerifiedAt pgtype.Timestamptz `json:"password_verified_at"`
	IdentityUserID     int32              `json:"identity_user_id"`
	IdentityType       string             `json:"identity_type"`
}

type LoginIdentityCreateNewPasswordLoginIdentityRow struct {
	PasswordLoginIdentityID int32 `json:"password_login_identity_id"`
	LoginIdentityID         int32 `json:"login_identity_id"`
}

// LoginIdentityCreateNewPasswordLoginIdentity
//
//	WITH new_identity AS (
//	 INSERT INTO login_identity (
//	    user_id,
//	    identity_type
//	 )
//	 VALUES (
//	    $6::int,
//	    $7::text
//	 )
//	 RETURNING id
//	)
//	INSERT INTO password_login_identity (
//	    login_identity_id,
//	    email,
//	    phone,
//	    hashed_pass,
//	    pass_salt,
//	    verified_at
//	)
//	VALUES (
//	    (SELECT id FROM new_identity),
//	    $1::text,
//	    $2::text,
//	    $3::text,
//	    $4::text,
//	    $5::timestamptz
//	)
//	RETURNING id AS password_login_identity_id, (SELECT id AS login_identity_id FROM new_identity)
func (q *Queries) LoginIdentityCreateNewPasswordLoginIdentity(ctx context.Context, arg LoginIdentityCreateNewPasswordLoginIdentityParams) (LoginIdentityCreateNewPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityCreateNewPasswordLoginIdentity,
		arg.PasswordEmail,
		arg.PasswordPhone,
		arg.PasswordHashedPass,
		arg.PasswordPassSalt,
		arg.PasswordVerifiedAt,
		arg.IdentityUserID,
		arg.IdentityType,
	)
	var i LoginIdentityCreateNewPasswordLoginIdentityRow
	err := row.Scan(&i.PasswordLoginIdentityID, &i.LoginIdentityID)
	return i, err
}

const loginIdentityCreateNewUserAndOIDCLoginIdentity = `-- name: LoginIdentityCreateNewUserAndOIDCLoginIdentity :one
WITH new_user AS (
  INSERT INTO users (
    username,
    profile_image,
    first_name,
    last_name,
    role_id
  )
  VALUES (
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5::int
  )
  RETURNING id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id
),
new_identity AS (
  INSERT INTO login_identity (
    user_id,
    identity_type
  )
  VALUES (
    (SELECT id FROM new_user),
    'oidc'
  )
  RETURNING id
),
ensure_provider AS (
    INSERT INTO oauth_provider (
        name,
        is_oidc_capable
    )
    VALUES (
        $6::text,
        $7::bool
    )
    ON CONFLICT (name) DO NOTHING
),
oauth_provider_row AS (
    SELECT id, name, is_oidc_capable, created_at, updated_at, deleted_at from oauth_provider WHERE name = $6::text
),
ensure_oauth_connection AS (
    INSERT INTO oauth_connection (
        provider_id,
        scopes
    )
    VALUES (
        (SELECT id FROM oauth_provider_row),
        $9::text[]
    )
    ON CONFLICT (provider_id, scopes) DO NOTHING
),
oauth_connection_row AS (
    SELECT id, provider_id, scopes, created_at, updated_at, deleted_at from oauth_connection WHERE provider_id = (SELECT id FROM oauth_provider_row) AND scopes = $8
),
new_oauth_integration AS (
    INSERT INTO oauth_integration (
        oauth_connection_id,
        integration_type
    )
    VALUES (
        (SELECT id FROM oauth_connection_row),
        'user'
    )
    RETURNING id
),
new_oauth_token AS (
    INSERT INTO oauth_token (
        oauth_integration_id,
        access_token,
        refresh_token,
        token_type,
        expires_at,
        issued_at
    )
    VALUES (
        (SELECT id FROM new_oauth_integration),
        $10::text,
        $11::text,
        $12::text,
        $13::timestamptz,
        $14::timestamptz
    )
),
new_user_integration AS (
    INSERT INTO user_integration (
        oauth_integration_id,
        user_id
    )
    VALUES (
        (SELECT id FROM new_oauth_integration),
        (SELECT id FROM new_user)
    )
    RETURNING id
),
new_oidc_user_integration_data AS (
    INSERT INTO oidc_user_integration_data (
        user_integration_id,
        sub,
        email,
        iss,
        aud,
        given_name,
        family_name,
        name,
        picture
    )
    VALUES (
        (SELECT id FROM new_user_integration),
        $15::text,
        $16::text,
        $17::text,
        $18::text,
        $19::text,
        $20::text,
        $21::text,
        $22::text
    )
    RETURNING id
),
new_oidc_login_identity AS (
    INSERT INTO oidc_login_identity (
        login_identity_id,
        oidc_user_integration_data_id
    )
    VALUES (
        (SELECT id FROM new_identity),
        (SELECT id FROM new_oidc_user_integration_data)
    )
)
SELECT id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id FROM new_user
`

type LoginIdentityCreateNewUserAndOIDCLoginIdentityParams struct {
	UserUsername               pgtype.Text        `json:"user_username"`
	UserProfileImage           pgtype.Text        `json:"user_profile_image"`
	UserFirstName              pgtype.Text        `json:"user_first_name"`
	UserLastName               pgtype.Text        `json:"user_last_name"`
	UserRoleID                 pgtype.Int4        `json:"user_role_id"`
	OauthProviderName          pgtype.Text        `json:"oauth_provider_name"`
	OauthProviderIsOidcCapable pgtype.Bool        `json:"oauth_provider_is_oidc_capable"`
	Column8                    []string           `json:"column_8"`
	OauthScopes                []string           `json:"oauth_scopes"`
	OauthAccessToken           pgtype.Text        `json:"oauth_access_token"`
	OauthRefreshToken          pgtype.Text        `json:"oauth_refresh_token"`
	OauthTokenType             pgtype.Text        `json:"oauth_token_type"`
	OauthTokenExpiresAt        pgtype.Timestamptz `json:"oauth_token_expires_at"`
	OauthTokenIssuedAt         pgtype.Timestamptz `json:"oauth_token_issued_at"`
	OidcSub                    pgtype.Text        `json:"oidc_sub"`
	OidcEmail                  pgtype.Text        `json:"oidc_email"`
	OidcIss                    pgtype.Text        `json:"oidc_iss"`
	OidcAud                    pgtype.Text        `json:"oidc_aud"`
	OidcGivenName              pgtype.Text        `json:"oidc_given_name"`
	OidcFamilyName             pgtype.Text        `json:"oidc_family_name"`
	OidcName                   pgtype.Text        `json:"oidc_name"`
	OidcPicture                pgtype.Text        `json:"oidc_picture"`
}

type LoginIdentityCreateNewUserAndOIDCLoginIdentityRow struct {
	ID           int32              `json:"id"`
	Username     string             `json:"username"`
	ProfileImage pgtype.Text        `json:"profile_image"`
	FirstName    string             `json:"first_name"`
	MiddleName   pgtype.Text        `json:"middle_name"`
	LastName     pgtype.Text        `json:"last_name"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	BlockedAt    pgtype.Timestamptz `json:"blocked_at"`
	BlockedUntil pgtype.Timestamptz `json:"blocked_until"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	RoleID       pgtype.Int4        `json:"role_id"`
}

// LoginIdentityCreateNewUserAndOIDCLoginIdentity
//
//	WITH new_user AS (
//	  INSERT INTO users (
//	    username,
//	    profile_image,
//	    first_name,
//	    last_name,
//	    role_id
//	  )
//	  VALUES (
//	    $1::text,
//	    $2::text,
//	    $3::text,
//	    $4::text,
//	    $5::int
//	  )
//	  RETURNING id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id
//	),
//	new_identity AS (
//	  INSERT INTO login_identity (
//	    user_id,
//	    identity_type
//	  )
//	  VALUES (
//	    (SELECT id FROM new_user),
//	    'oidc'
//	  )
//	  RETURNING id
//	),
//	ensure_provider AS (
//	    INSERT INTO oauth_provider (
//	        name,
//	        is_oidc_capable
//	    )
//	    VALUES (
//	        $6::text,
//	        $7::bool
//	    )
//	    ON CONFLICT (name) DO NOTHING
//	),
//	oauth_provider_row AS (
//	    SELECT id, name, is_oidc_capable, created_at, updated_at, deleted_at from oauth_provider WHERE name = $6::text
//	),
//	ensure_oauth_connection AS (
//	    INSERT INTO oauth_connection (
//	        provider_id,
//	        scopes
//	    )
//	    VALUES (
//	        (SELECT id FROM oauth_provider_row),
//	        $9::text[]
//	    )
//	    ON CONFLICT (provider_id, scopes) DO NOTHING
//	),
//	oauth_connection_row AS (
//	    SELECT id, provider_id, scopes, created_at, updated_at, deleted_at from oauth_connection WHERE provider_id = (SELECT id FROM oauth_provider_row) AND scopes = $8
//	),
//	new_oauth_integration AS (
//	    INSERT INTO oauth_integration (
//	        oauth_connection_id,
//	        integration_type
//	    )
//	    VALUES (
//	        (SELECT id FROM oauth_connection_row),
//	        'user'
//	    )
//	    RETURNING id
//	),
//	new_oauth_token AS (
//	    INSERT INTO oauth_token (
//	        oauth_integration_id,
//	        access_token,
//	        refresh_token,
//	        token_type,
//	        expires_at,
//	        issued_at
//	    )
//	    VALUES (
//	        (SELECT id FROM new_oauth_integration),
//	        $10::text,
//	        $11::text,
//	        $12::text,
//	        $13::timestamptz,
//	        $14::timestamptz
//	    )
//	),
//	new_user_integration AS (
//	    INSERT INTO user_integration (
//	        oauth_integration_id,
//	        user_id
//	    )
//	    VALUES (
//	        (SELECT id FROM new_oauth_integration),
//	        (SELECT id FROM new_user)
//	    )
//	    RETURNING id
//	),
//	new_oidc_user_integration_data AS (
//	    INSERT INTO oidc_user_integration_data (
//	        user_integration_id,
//	        sub,
//	        email,
//	        iss,
//	        aud,
//	        given_name,
//	        family_name,
//	        name,
//	        picture
//	    )
//	    VALUES (
//	        (SELECT id FROM new_user_integration),
//	        $15::text,
//	        $16::text,
//	        $17::text,
//	        $18::text,
//	        $19::text,
//	        $20::text,
//	        $21::text,
//	        $22::text
//	    )
//	    RETURNING id
//	),
//	new_oidc_login_identity AS (
//	    INSERT INTO oidc_login_identity (
//	        login_identity_id,
//	        oidc_user_integration_data_id
//	    )
//	    VALUES (
//	        (SELECT id FROM new_identity),
//	        (SELECT id FROM new_oidc_user_integration_data)
//	    )
//	)
//	SELECT id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id FROM new_user
func (q *Queries) LoginIdentityCreateNewUserAndOIDCLoginIdentity(ctx context.Context, arg LoginIdentityCreateNewUserAndOIDCLoginIdentityParams) (LoginIdentityCreateNewUserAndOIDCLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityCreateNewUserAndOIDCLoginIdentity,
		arg.UserUsername,
		arg.UserProfileImage,
		arg.UserFirstName,
		arg.UserLastName,
		arg.UserRoleID,
		arg.OauthProviderName,
		arg.OauthProviderIsOidcCapable,
		arg.Column8,
		arg.OauthScopes,
		arg.OauthAccessToken,
		arg.OauthRefreshToken,
		arg.OauthTokenType,
		arg.OauthTokenExpiresAt,
		arg.OauthTokenIssuedAt,
		arg.OidcSub,
		arg.OidcEmail,
		arg.OidcIss,
		arg.OidcAud,
		arg.OidcGivenName,
		arg.OidcFamilyName,
		arg.OidcName,
		arg.OidcPicture,
	)
	var i LoginIdentityCreateNewUserAndOIDCLoginIdentityRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ProfileImage,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BlockedAt,
		&i.BlockedUntil,
		&i.DeletedAt,
		&i.RoleID,
	)
	return i, err
}

const loginIdentityCreateNewUserAndPasswordLoginIdentity = `-- name: LoginIdentityCreateNewUserAndPasswordLoginIdentity :one
WITH new_user AS (
  INSERT INTO users (
    username,
    profile_image,
    first_name,
    last_name,
    role_id
  )
  VALUES (
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5::int
  )
  RETURNING id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id
),
new_identity AS (
  INSERT INTO login_identity (
    user_id,
    identity_type
  )
  VALUES (
    (SELECT id FROM new_user),
    $6::text
  )
  RETURNING id
),
final_insert AS (
  INSERT INTO password_login_identity (
    login_identity_id,
    email,
    phone,
    hashed_pass,
    pass_salt,
    verified_at
  )
  VALUES (
    (SELECT id FROM new_identity),
    $7::text,
    $8::text,
    $9::text,
    $10::text,
    $11::timestamptz
  )
)
SELECT id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id FROM new_user
`

type LoginIdentityCreateNewUserAndPasswordLoginIdentityParams struct {
	UserUsername       string             `json:"user_username"`
	UserProfileImage   pgtype.Text        `json:"user_profile_image"`
	UserFirstName      string             `json:"user_first_name"`
	UserLastName       pgtype.Text        `json:"user_last_name"`
	UserRoleID         pgtype.Int4        `json:"user_role_id"`
	IdentityType       string             `json:"identity_type"`
	PasswordEmail      pgtype.Text        `json:"password_email"`
	PasswordPhone      pgtype.Text        `json:"password_phone"`
	PasswordHashedPass string             `json:"password_hashed_pass"`
	PasswordPassSalt   string             `json:"password_pass_salt"`
	PasswordVerifiedAt pgtype.Timestamptz `json:"password_verified_at"`
}

type LoginIdentityCreateNewUserAndPasswordLoginIdentityRow struct {
	ID           int32              `json:"id"`
	Username     string             `json:"username"`
	ProfileImage pgtype.Text        `json:"profile_image"`
	FirstName    string             `json:"first_name"`
	MiddleName   pgtype.Text        `json:"middle_name"`
	LastName     pgtype.Text        `json:"last_name"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	BlockedAt    pgtype.Timestamptz `json:"blocked_at"`
	BlockedUntil pgtype.Timestamptz `json:"blocked_until"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	RoleID       pgtype.Int4        `json:"role_id"`
}

// LoginIdentityCreateNewUserAndPasswordLoginIdentity
//
//	WITH new_user AS (
//	  INSERT INTO users (
//	    username,
//	    profile_image,
//	    first_name,
//	    last_name,
//	    role_id
//	  )
//	  VALUES (
//	    $1::text,
//	    $2::text,
//	    $3::text,
//	    $4::text,
//	    $5::int
//	  )
//	  RETURNING id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id
//	),
//	new_identity AS (
//	  INSERT INTO login_identity (
//	    user_id,
//	    identity_type
//	  )
//	  VALUES (
//	    (SELECT id FROM new_user),
//	    $6::text
//	  )
//	  RETURNING id
//	),
//	final_insert AS (
//	  INSERT INTO password_login_identity (
//	    login_identity_id,
//	    email,
//	    phone,
//	    hashed_pass,
//	    pass_salt,
//	    verified_at
//	  )
//	  VALUES (
//	    (SELECT id FROM new_identity),
//	    $7::text,
//	    $8::text,
//	    $9::text,
//	    $10::text,
//	    $11::timestamptz
//	  )
//	)
//	SELECT id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id FROM new_user
func (q *Queries) LoginIdentityCreateNewUserAndPasswordLoginIdentity(ctx context.Context, arg LoginIdentityCreateNewUserAndPasswordLoginIdentityParams) (LoginIdentityCreateNewUserAndPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityCreateNewUserAndPasswordLoginIdentity,
		arg.UserUsername,
		arg.UserProfileImage,
		arg.UserFirstName,
		arg.UserLastName,
		arg.UserRoleID,
		arg.IdentityType,
		arg.PasswordEmail,
		arg.PasswordPhone,
		arg.PasswordHashedPass,
		arg.PasswordPassSalt,
		arg.PasswordVerifiedAt,
	)
	var i LoginIdentityCreateNewUserAndPasswordLoginIdentityRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ProfileImage,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BlockedAt,
		&i.BlockedUntil,
		&i.DeletedAt,
		&i.RoleID,
	)
	return i, err
}

const loginIdentityGetAllByUserId = `-- name: LoginIdentityGetAllByUserId :many
SELECT
  li.id AS login_identity_id,
  li.user_id AS login_identity_user_id,
  li.identity_type AS login_identity_identity_type,
  li.is_primary AS login_identity_is_primary,
  li.last_used_at AS login_identity_last_used_at,

  -- Password-based
  pli.id AS password_id,
  pli.email  AS password_email,
  pli.phone  AS password_phone,
  pli.hashed_pass  AS password_hashed_pass,
  pli.pass_salt  AS password_pass_salt,
  pli.verified_at AS password_verified_at,

  -- Guest-based
  gli.id AS guest_id,
  gli.device_id AS guest_device_id,

  -- OIDC-based
  oud.id AS oidc_data_id,
  oud.sub AS oidc_data_sub,
  oud.email AS oidc_data_email,
  oud.iss AS oidc_data_issuer,
  oud.aud AS oidc_data_audience,
  oud.given_name AS oidc_data_given_name,
  oud.family_name AS oidc_data_family_name,
  oud.name AS oidc_data_name,
  oud.picture AS oidc_data_picture,

  -- oauth_provider
  op.name AS oauth_provider_name

FROM active_login_identity AS li
LEFT JOIN active_password_login_identity AS pli
  ON li.id = pli.login_identity_id
LEFT JOIN active_guest_login_identity AS gli
  ON li.id = gli.login_identity_id
LEFT JOIN active_oidc_login_identity AS oli
  ON li.id = oli.login_identity_id
LEFT JOIN active_oidc_user_integration_data AS oud
  ON oli.oidc_user_integration_data_id = oud.id
LEFT JOIN user_integration AS ui
  ON oud.user_integration_id = ui.id
LEFT JOIN oauth_integration AS oi
  ON ui.oauth_integration_id = oi.id
LEFT JOIN oauth_connection AS oc
  ON oi.oauth_connection_id = oc.id
LEFT JOIN oauth_provider AS op
  ON oc.provider_id = op.id

WHERE li.user_id = $1
ORDER BY li.is_primary DESC, li.last_used_at DESC
`

type LoginIdentityGetAllByUserIdRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	LoginIdentityUserID       int32              `json:"login_identity_user_id"`
	LoginIdentityIdentityType string             `json:"login_identity_identity_type"`
	LoginIdentityIsPrimary    pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt   pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordID                pgtype.Int4        `json:"password_id"`
	PasswordEmail             pgtype.Text        `json:"password_email"`
	PasswordPhone             pgtype.Text        `json:"password_phone"`
	PasswordHashedPass        pgtype.Text        `json:"password_hashed_pass"`
	PasswordPassSalt          pgtype.Text        `json:"password_pass_salt"`
	PasswordVerifiedAt        pgtype.Timestamptz `json:"password_verified_at"`
	GuestID                   pgtype.Int4        `json:"guest_id"`
	GuestDeviceID             pgtype.Text        `json:"guest_device_id"`
	OidcDataID                pgtype.Int4        `json:"oidc_data_id"`
	OidcDataSub               pgtype.Text        `json:"oidc_data_sub"`
	OidcDataEmail             pgtype.Text        `json:"oidc_data_email"`
	OidcDataIssuer            pgtype.Text        `json:"oidc_data_issuer"`
	OidcDataAudience          pgtype.Text        `json:"oidc_data_audience"`
	OidcDataGivenName         pgtype.Text        `json:"oidc_data_given_name"`
	OidcDataFamilyName        pgtype.Text        `json:"oidc_data_family_name"`
	OidcDataName              pgtype.Text        `json:"oidc_data_name"`
	OidcDataPicture           pgtype.Text        `json:"oidc_data_picture"`
	OauthProviderName         pgtype.Text        `json:"oauth_provider_name"`
}

// LoginIdentityGetAllByUserId
//
//	SELECT
//	  li.id AS login_identity_id,
//	  li.user_id AS login_identity_user_id,
//	  li.identity_type AS login_identity_identity_type,
//	  li.is_primary AS login_identity_is_primary,
//	  li.last_used_at AS login_identity_last_used_at,
//
//	  -- Password-based
//	  pli.id AS password_id,
//	  pli.email  AS password_email,
//	  pli.phone  AS password_phone,
//	  pli.hashed_pass  AS password_hashed_pass,
//	  pli.pass_salt  AS password_pass_salt,
//	  pli.verified_at AS password_verified_at,
//
//	  -- Guest-based
//	  gli.id AS guest_id,
//	  gli.device_id AS guest_device_id,
//
//	  -- OIDC-based
//	  oud.id AS oidc_data_id,
//	  oud.sub AS oidc_data_sub,
//	  oud.email AS oidc_data_email,
//	  oud.iss AS oidc_data_issuer,
//	  oud.aud AS oidc_data_audience,
//	  oud.given_name AS oidc_data_given_name,
//	  oud.family_name AS oidc_data_family_name,
//	  oud.name AS oidc_data_name,
//	  oud.picture AS oidc_data_picture,
//
//	  -- oauth_provider
//	  op.name AS oauth_provider_name
//
//	FROM active_login_identity AS li
//	LEFT JOIN active_password_login_identity AS pli
//	  ON li.id = pli.login_identity_id
//	LEFT JOIN active_guest_login_identity AS gli
//	  ON li.id = gli.login_identity_id
//	LEFT JOIN active_oidc_login_identity AS oli
//	  ON li.id = oli.login_identity_id
//	LEFT JOIN active_oidc_user_integration_data AS oud
//	  ON oli.oidc_user_integration_data_id = oud.id
//	LEFT JOIN user_integration AS ui
//	  ON oud.user_integration_id = ui.id
//	LEFT JOIN oauth_integration AS oi
//	  ON ui.oauth_integration_id = oi.id
//	LEFT JOIN oauth_connection AS oc
//	  ON oi.oauth_connection_id = oc.id
//	LEFT JOIN oauth_provider AS op
//	  ON oc.provider_id = op.id
//
//	WHERE li.user_id = $1
//	ORDER BY li.is_primary DESC, li.last_used_at DESC
func (q *Queries) LoginIdentityGetAllByUserId(ctx context.Context, userID int32) ([]LoginIdentityGetAllByUserIdRow, error) {
	rows, err := q.db.Query(ctx, loginIdentityGetAllByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginIdentityGetAllByUserIdRow{}
	for rows.Next() {
		var i LoginIdentityGetAllByUserIdRow
		if err := rows.Scan(
			&i.LoginIdentityID,
			&i.LoginIdentityUserID,
			&i.LoginIdentityIdentityType,
			&i.LoginIdentityIsPrimary,
			&i.LoginIdentityLastUsedAt,
			&i.PasswordID,
			&i.PasswordEmail,
			&i.PasswordPhone,
			&i.PasswordHashedPass,
			&i.PasswordPassSalt,
			&i.PasswordVerifiedAt,
			&i.GuestID,
			&i.GuestDeviceID,
			&i.OidcDataID,
			&i.OidcDataSub,
			&i.OidcDataEmail,
			&i.OidcDataIssuer,
			&i.OidcDataAudience,
			&i.OidcDataGivenName,
			&i.OidcDataFamilyName,
			&i.OidcDataName,
			&i.OidcDataPicture,
			&i.OauthProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginIdentityGetAllPasswordLoginIdentitiesByUserId = `-- name: LoginIdentityGetAllPasswordLoginIdentitiesByUserId :many
SELECT
  li.id AS login_identity_id,
  li.user_id AS login_identity_user_id,
  li.identity_type AS login_identity_identity_type,
  li.is_primary AS login_identity_is_primary,
  li.last_used_at AS login_identity_last_used_at,

  -- Password-based
  pli.id AS password_id,
  pli.email  AS password_email,
  pli.phone  AS password_phone,
  pli.hashed_pass  AS password_hashed_pass,
  pli.pass_salt  AS password_pass_salt,
  pli.verified_at AS password_verified_at
FROM active_login_identity AS li
LEFT JOIN active_password_login_identity AS pli
  ON li.id = pli.login_identity_id
WHERE li.user_id = $1
ORDER BY li.is_primary DESC, li.last_used_at DESC
`

type LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	LoginIdentityUserID       int32              `json:"login_identity_user_id"`
	LoginIdentityIdentityType string             `json:"login_identity_identity_type"`
	LoginIdentityIsPrimary    pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt   pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordID                pgtype.Int4        `json:"password_id"`
	PasswordEmail             pgtype.Text        `json:"password_email"`
	PasswordPhone             pgtype.Text        `json:"password_phone"`
	PasswordHashedPass        pgtype.Text        `json:"password_hashed_pass"`
	PasswordPassSalt          pgtype.Text        `json:"password_pass_salt"`
	PasswordVerifiedAt        pgtype.Timestamptz `json:"password_verified_at"`
}

// LoginIdentityGetAllPasswordLoginIdentitiesByUserId
//
//	SELECT
//	  li.id AS login_identity_id,
//	  li.user_id AS login_identity_user_id,
//	  li.identity_type AS login_identity_identity_type,
//	  li.is_primary AS login_identity_is_primary,
//	  li.last_used_at AS login_identity_last_used_at,
//
//	  -- Password-based
//	  pli.id AS password_id,
//	  pli.email  AS password_email,
//	  pli.phone  AS password_phone,
//	  pli.hashed_pass  AS password_hashed_pass,
//	  pli.pass_salt  AS password_pass_salt,
//	  pli.verified_at AS password_verified_at
//	FROM active_login_identity AS li
//	LEFT JOIN active_password_login_identity AS pli
//	  ON li.id = pli.login_identity_id
//	WHERE li.user_id = $1
//	ORDER BY li.is_primary DESC, li.last_used_at DESC
func (q *Queries) LoginIdentityGetAllPasswordLoginIdentitiesByUserId(ctx context.Context, userID int32) ([]LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow, error) {
	rows, err := q.db.Query(ctx, loginIdentityGetAllPasswordLoginIdentitiesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow{}
	for rows.Next() {
		var i LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow
		if err := rows.Scan(
			&i.LoginIdentityID,
			&i.LoginIdentityUserID,
			&i.LoginIdentityIdentityType,
			&i.LoginIdentityIsPrimary,
			&i.LoginIdentityLastUsedAt,
			&i.PasswordID,
			&i.PasswordEmail,
			&i.PasswordPhone,
			&i.PasswordHashedPass,
			&i.PasswordPassSalt,
			&i.PasswordVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginIdentityGetOIDCLoginIdentity = `-- name: LoginIdentityGetOIDCLoginIdentity :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary,
    li.last_used_at,

    oli.id AS oidc_login_identity_id,

    oidc_data.id AS oidc_data_id,
    oidc_data.user_integration_id AS oidc_data_user_integration_id,
    oidc_data.sub AS oidc_data_sub,
    oidc_data.email AS oidc_data_email,
    oidc_data.iss AS oidc_data_iss,
    oidc_data.aud AS oidc_data_aud,
    oidc_data.given_name AS oidc_data_given_name,
    oidc_data.family_name AS oidc_data_family_name,
    oidc_data.name AS oidc_data_name,
    oidc_data.picture AS oidc_data_picture
FROM active_login_identity AS li
    JOIN active_oidc_login_identity oli
        ON li.id = oli.login_identity_id
    JOIN active_oidc_user_integration_data AS oidc_data
        ON oli.oidc_user_integration_data_id = oidc_data.id
WHERE li.identity_type = 'oidc'
    AND oidc_data.sub = $1::text
LIMIT 1
`

type LoginIdentityGetOIDCLoginIdentityRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	UserID                    int32              `json:"user_id"`
	IdentityType              string             `json:"identity_type"`
	IsPrimary                 pgtype.Bool        `json:"is_primary"`
	LastUsedAt                pgtype.Timestamptz `json:"last_used_at"`
	OidcLoginIdentityID       int32              `json:"oidc_login_identity_id"`
	OidcDataID                int32              `json:"oidc_data_id"`
	OidcDataUserIntegrationID int32              `json:"oidc_data_user_integration_id"`
	OidcDataSub               string             `json:"oidc_data_sub"`
	OidcDataEmail             pgtype.Text        `json:"oidc_data_email"`
	OidcDataIss               string             `json:"oidc_data_iss"`
	OidcDataAud               string             `json:"oidc_data_aud"`
	OidcDataGivenName         pgtype.Text        `json:"oidc_data_given_name"`
	OidcDataFamilyName        pgtype.Text        `json:"oidc_data_family_name"`
	OidcDataName              pgtype.Text        `json:"oidc_data_name"`
	OidcDataPicture           pgtype.Text        `json:"oidc_data_picture"`
}

// LoginIdentityGetOIDCLoginIdentity
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary,
//	    li.last_used_at,
//
//	    oli.id AS oidc_login_identity_id,
//
//	    oidc_data.id AS oidc_data_id,
//	    oidc_data.user_integration_id AS oidc_data_user_integration_id,
//	    oidc_data.sub AS oidc_data_sub,
//	    oidc_data.email AS oidc_data_email,
//	    oidc_data.iss AS oidc_data_iss,
//	    oidc_data.aud AS oidc_data_aud,
//	    oidc_data.given_name AS oidc_data_given_name,
//	    oidc_data.family_name AS oidc_data_family_name,
//	    oidc_data.name AS oidc_data_name,
//	    oidc_data.picture AS oidc_data_picture
//	FROM active_login_identity AS li
//	    JOIN active_oidc_login_identity oli
//	        ON li.id = oli.login_identity_id
//	    JOIN active_oidc_user_integration_data AS oidc_data
//	        ON oli.oidc_user_integration_data_id = oidc_data.id
//	WHERE li.identity_type = 'oidc'
//	    AND oidc_data.sub = $1::text
//	LIMIT 1
func (q *Queries) LoginIdentityGetOIDCLoginIdentity(ctx context.Context, oidcSub string) (LoginIdentityGetOIDCLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetOIDCLoginIdentity, oidcSub)
	var i LoginIdentityGetOIDCLoginIdentityRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.IsPrimary,
		&i.LastUsedAt,
		&i.OidcLoginIdentityID,
		&i.OidcDataID,
		&i.OidcDataUserIntegrationID,
		&i.OidcDataSub,
		&i.OidcDataEmail,
		&i.OidcDataIss,
		&i.OidcDataAud,
		&i.OidcDataGivenName,
		&i.OidcDataFamilyName,
		&i.OidcDataName,
		&i.OidcDataPicture,
	)
	return i, err
}

const loginIdentityGetPasswordLoginIdentity = `-- name: LoginIdentityGetPasswordLoginIdentity :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary AS login_identity_is_primary,
    li.last_used_at AS login_identity_last_used_at,

    pli.id AS password_login_identity_id,
    pli.email ,
    pli.phone,
    pli.hashed_pass,
    pli.pass_salt,
    pli.verified_at
FROM active_login_identity AS li
    JOIN active_password_login_identity pli
        ON li.id = pli.login_identity_id
WHERE li.identity_type = $1::text
    AND (
      ($1::text = 'email' AND pli.email = $2::text)
      OR
      ($1::text = 'phone' AND pli.phone = $2::text)
    )
LIMIT 1
`

type LoginIdentityGetPasswordLoginIdentityParams struct {
	IdentityType  string `json:"identity_type"`
	IdentityValue string `json:"identity_value"`
}

type LoginIdentityGetPasswordLoginIdentityRow struct {
	LoginIdentityID         int32              `json:"login_identity_id"`
	UserID                  int32              `json:"user_id"`
	IdentityType            string             `json:"identity_type"`
	LoginIdentityIsPrimary  pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordLoginIdentityID int32              `json:"password_login_identity_id"`
	Email                   pgtype.Text        `json:"email"`
	Phone                   pgtype.Text        `json:"phone"`
	HashedPass              string             `json:"hashed_pass"`
	PassSalt                string             `json:"pass_salt"`
	VerifiedAt              pgtype.Timestamptz `json:"verified_at"`
}

// LoginIdentityGetPasswordLoginIdentity
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary AS login_identity_is_primary,
//	    li.last_used_at AS login_identity_last_used_at,
//
//	    pli.id AS password_login_identity_id,
//	    pli.email ,
//	    pli.phone,
//	    pli.hashed_pass,
//	    pli.pass_salt,
//	    pli.verified_at
//	FROM active_login_identity AS li
//	    JOIN active_password_login_identity pli
//	        ON li.id = pli.login_identity_id
//	WHERE li.identity_type = $1::text
//	    AND (
//	      ($1::text = 'email' AND pli.email = $2::text)
//	      OR
//	      ($1::text = 'phone' AND pli.phone = $2::text)
//	    )
//	LIMIT 1
func (q *Queries) LoginIdentityGetPasswordLoginIdentity(ctx context.Context, arg LoginIdentityGetPasswordLoginIdentityParams) (LoginIdentityGetPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetPasswordLoginIdentity, arg.IdentityType, arg.IdentityValue)
	var i LoginIdentityGetPasswordLoginIdentityRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.LoginIdentityIsPrimary,
		&i.LoginIdentityLastUsedAt,
		&i.PasswordLoginIdentityID,
		&i.Email,
		&i.Phone,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
	)
	return i, err
}

const loginIdentityGetPasswordLoginIdentityWithUser = `-- name: LoginIdentityGetPasswordLoginIdentityWithUser :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary,
    li.last_used_at,

    pli.id AS password_login_identity_id,
    pli.email,
    pli.phone,
    pli.hashed_pass,
    pli.pass_salt,
    pli.verified_at,

    u.id as user_id,
    u.username as user_username,
    u.profile_image as user_profile_image,
    u.first_name as user_first_name,
    u.middle_name as user_middle_name,
    u.last_name as user_last_name,
    u.blocked_at as user_blocked_at,
    u.blocked_until as user_blocked_until,
    u.role_id as user_role_id
FROM not_deleted_users AS u
    JOIN active_login_identity AS li
        ON u.id = li.user_id
    JOIN active_password_login_identity pli
        ON li.id = pli.login_identity_id
WHERE li.identity_type = $1::text
    AND (
      ($1::text = 'email' AND pli.email = $2::text)
      OR
      ($1::text = 'phone' AND pli.phone = $2::text)
    )
LIMIT 1
`

type LoginIdentityGetPasswordLoginIdentityWithUserParams struct {
	IdentityType  string `json:"identity_type"`
	IdentityValue string `json:"identity_value"`
}

type LoginIdentityGetPasswordLoginIdentityWithUserRow struct {
	LoginIdentityID         int32              `json:"login_identity_id"`
	UserID                  int32              `json:"user_id"`
	IdentityType            string             `json:"identity_type"`
	IsPrimary               pgtype.Bool        `json:"is_primary"`
	LastUsedAt              pgtype.Timestamptz `json:"last_used_at"`
	PasswordLoginIdentityID int32              `json:"password_login_identity_id"`
	Email                   pgtype.Text        `json:"email"`
	Phone                   pgtype.Text        `json:"phone"`
	HashedPass              string             `json:"hashed_pass"`
	PassSalt                string             `json:"pass_salt"`
	VerifiedAt              pgtype.Timestamptz `json:"verified_at"`
	UserID_2                int32              `json:"user_id_2"`
	UserUsername            string             `json:"user_username"`
	UserProfileImage        pgtype.Text        `json:"user_profile_image"`
	UserFirstName           string             `json:"user_first_name"`
	UserMiddleName          pgtype.Text        `json:"user_middle_name"`
	UserLastName            pgtype.Text        `json:"user_last_name"`
	UserBlockedAt           pgtype.Timestamptz `json:"user_blocked_at"`
	UserBlockedUntil        pgtype.Timestamptz `json:"user_blocked_until"`
	UserRoleID              pgtype.Int4        `json:"user_role_id"`
}

// LoginIdentityGetPasswordLoginIdentityWithUser
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary,
//	    li.last_used_at,
//
//	    pli.id AS password_login_identity_id,
//	    pli.email,
//	    pli.phone,
//	    pli.hashed_pass,
//	    pli.pass_salt,
//	    pli.verified_at,
//
//	    u.id as user_id,
//	    u.username as user_username,
//	    u.profile_image as user_profile_image,
//	    u.first_name as user_first_name,
//	    u.middle_name as user_middle_name,
//	    u.last_name as user_last_name,
//	    u.blocked_at as user_blocked_at,
//	    u.blocked_until as user_blocked_until,
//	    u.role_id as user_role_id
//	FROM not_deleted_users AS u
//	    JOIN active_login_identity AS li
//	        ON u.id = li.user_id
//	    JOIN active_password_login_identity pli
//	        ON li.id = pli.login_identity_id
//	WHERE li.identity_type = $1::text
//	    AND (
//	      ($1::text = 'email' AND pli.email = $2::text)
//	      OR
//	      ($1::text = 'phone' AND pli.phone = $2::text)
//	    )
//	LIMIT 1
func (q *Queries) LoginIdentityGetPasswordLoginIdentityWithUser(ctx context.Context, arg LoginIdentityGetPasswordLoginIdentityWithUserParams) (LoginIdentityGetPasswordLoginIdentityWithUserRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetPasswordLoginIdentityWithUser, arg.IdentityType, arg.IdentityValue)
	var i LoginIdentityGetPasswordLoginIdentityWithUserRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.IsPrimary,
		&i.LastUsedAt,
		&i.PasswordLoginIdentityID,
		&i.Email,
		&i.Phone,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
		&i.UserID_2,
		&i.UserUsername,
		&i.UserProfileImage,
		&i.UserFirstName,
		&i.UserMiddleName,
		&i.UserLastName,
		&i.UserBlockedAt,
		&i.UserBlockedUntil,
		&i.UserRoleID,
	)
	return i, err
}

const loginIdentityIsEmailUsed = `-- name: LoginIdentityIsEmailUsed :one
SELECT COUNT(*) FROM active_password_login_identity WHERE email = $1
`

// LoginIdentityIsEmailUsed
//
//	SELECT COUNT(*) FROM active_password_login_identity WHERE email = $1
func (q *Queries) LoginIdentityIsEmailUsed(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsEmailUsed, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const loginIdentityIsOidcEmailUsed = `-- name: LoginIdentityIsOidcEmailUsed :one
SELECT COUNT(*) FROM active_oidc_user_integration_data WHERE email = $1
`

// LoginIdentityIsOidcEmailUsed
//
//	SELECT COUNT(*) FROM active_oidc_user_integration_data WHERE email = $1
func (q *Queries) LoginIdentityIsOidcEmailUsed(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsOidcEmailUsed, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const loginIdentityIsPhoneUsed = `-- name: LoginIdentityIsPhoneUsed :one
SELECT COUNT(*) FROM active_password_login_identity WHERE phone = $1
`

// LoginIdentityIsPhoneUsed
//
//	SELECT COUNT(*) FROM active_password_login_identity WHERE phone = $1
func (q *Queries) LoginIdentityIsPhoneUsed(ctx context.Context, phone pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsPhoneUsed, phone)
	var count int64
	err := row.Scan(&count)
	return count, err
}
