// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: otp.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewOtp = `-- name: CreateNewOtp :one
INSERT INTO otp (
        code,
        intent,
        otp_for,
        using_session_id,
        expires_at
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, code, hit_count, created_at, updated_at, expires_at, deleted_at, intent, otp_for, using_session_id
`

type CreateNewOtpParams struct {
	Code           string             `json:"code"`
	Intent         string             `json:"intent"`
	OtpFor         int32              `json:"otp_for"`
	UsingSessionID int32              `json:"using_session_id"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
}

// CreateNewOtp
//
//	INSERT INTO otp (
//	        code,
//	        intent,
//	        otp_for,
//	        using_session_id,
//	        expires_at
//	    )
//	VALUES ($1, $2, $3, $4, $5)
//	RETURNING id, code, hit_count, created_at, updated_at, expires_at, deleted_at, intent, otp_for, using_session_id
func (q *Queries) CreateNewOtp(ctx context.Context, arg CreateNewOtpParams) (Otp, error) {
	row := q.db.QueryRow(ctx, createNewOtp,
		arg.Code,
		arg.Intent,
		arg.OtpFor,
		arg.UsingSessionID,
		arg.ExpiresAt,
	)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.HitCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
		&i.Intent,
		&i.OtpFor,
		&i.UsingSessionID,
	)
	return i, err
}

const getActiveOtpByIdPairedWithSessionId = `-- name: GetActiveOtpByIdPairedWithSessionId :one
SELECT id, code, hit_count, created_at, updated_at, expires_at, deleted_at, intent, otp_for, using_session_id
FROM otp
WHERE id = $1
    AND using_session_id = $2
    AND hit_count < 3
    AND expires_at > NOW()
    AND deleted_at IS NULL
LIMIT 1
`

type GetActiveOtpByIdPairedWithSessionIdParams struct {
	ID             int32 `json:"id"`
	UsingSessionID int32 `json:"using_session_id"`
}

// GetActiveOtpByIdPairedWithSessionId
//
//	SELECT id, code, hit_count, created_at, updated_at, expires_at, deleted_at, intent, otp_for, using_session_id
//	FROM otp
//	WHERE id = $1
//	    AND using_session_id = $2
//	    AND hit_count < 3
//	    AND expires_at > NOW()
//	    AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetActiveOtpByIdPairedWithSessionId(ctx context.Context, arg GetActiveOtpByIdPairedWithSessionIdParams) (Otp, error) {
	row := q.db.QueryRow(ctx, getActiveOtpByIdPairedWithSessionId, arg.ID, arg.UsingSessionID)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.HitCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
		&i.Intent,
		&i.OtpFor,
		&i.UsingSessionID,
	)
	return i, err
}

const recordHitForOtp = `-- name: RecordHitForOtp :one
UPDATE otp
SET hit_count = hit_count + 1
WHERE id = $1
RETURNING id, code, hit_count, created_at, updated_at, expires_at, deleted_at, intent, otp_for, using_session_id
`

// RecordHitForOtp
//
//	UPDATE otp
//	SET hit_count = hit_count + 1
//	WHERE id = $1
//	RETURNING id, code, hit_count, created_at, updated_at, expires_at, deleted_at, intent, otp_for, using_session_id
func (q *Queries) RecordHitForOtp(ctx context.Context, id int32) (Otp, error) {
	row := q.db.QueryRow(ctx, recordHitForOtp, id)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.HitCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
		&i.Intent,
		&i.OtpFor,
		&i.UsingSessionID,
	)
	return i, err
}

const softDeleteOtp = `-- name: SoftDeleteOtp :exec
UPDATE otp
SET deleted_at = NOW()
WHERE id = $1
`

// SoftDeleteOtp
//
//	UPDATE otp
//	SET deleted_at = NOW()
//	WHERE id = $1
func (q *Queries) SoftDeleteOtp(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteOtp, id)
	return err
}
