// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: login_identity.sql

package database_queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const loginIdentityChangePasswordLoginIdentityByUserId = `-- name: LoginIdentityChangePasswordLoginIdentityByUserId :exec
UPDATE password_login_identity pli
SET
    hashed_pass = $2,
    pass_salt = $3
FROM active_login_identity li
WHERE pli.login_identity_id = li.id
  AND li.user_id = $1
`

type LoginIdentityChangePasswordLoginIdentityByUserIdParams struct {
	UserID     int32  `json:"user_id"`
	HashedPass string `json:"hashed_pass"`
	PassSalt   string `json:"pass_salt"`
}

// LoginIdentityChangePasswordLoginIdentityByUserId
//
//	UPDATE password_login_identity pli
//	SET
//	    hashed_pass = $2,
//	    pass_salt = $3
//	FROM active_login_identity li
//	WHERE pli.login_identity_id = li.id
//	  AND li.user_id = $1
func (q *Queries) LoginIdentityChangePasswordLoginIdentityByUserId(ctx context.Context, arg LoginIdentityChangePasswordLoginIdentityByUserIdParams) error {
	_, err := q.db.Exec(ctx, loginIdentityChangePasswordLoginIdentityByUserId, arg.UserID, arg.HashedPass, arg.PassSalt)
	return err
}

const loginIdentityCreateNewPasswordLoginIdentity = `-- name: LoginIdentityCreateNewPasswordLoginIdentity :one
WITH new_identity AS (
 INSERT INTO login_identity (
    user_id,
    identity_type
 )
 VALUES (
    $6::int,
    $7::text
 )
 RETURNING id
)
INSERT INTO password_login_identity (
    login_identity_id,
    email,
    phone,
    hashed_pass,
    pass_salt,
    verified_at
)
VALUES (
    (SELECT id FROM new_identity),
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5::timestamptz
)
RETURNING id AS password_login_identity_id, (SELECT id AS login_identity_id FROM new_identity)
`

type LoginIdentityCreateNewPasswordLoginIdentityParams struct {
	PasswordEmail      pgtype.Text        `json:"password_email"`
	PasswordPhone      pgtype.Text        `json:"password_phone"`
	PasswordHashedPass string             `json:"password_hashed_pass"`
	PasswordPassSalt   string             `json:"password_pass_salt"`
	PasswordVerifiedAt pgtype.Timestamptz `json:"password_verified_at"`
	IdentityUserID     int32              `json:"identity_user_id"`
	IdentityType       string             `json:"identity_type"`
}

type LoginIdentityCreateNewPasswordLoginIdentityRow struct {
	PasswordLoginIdentityID int32 `json:"password_login_identity_id"`
	LoginIdentityID         int32 `json:"login_identity_id"`
}

// LoginIdentityCreateNewPasswordLoginIdentity
//
//	WITH new_identity AS (
//	 INSERT INTO login_identity (
//	    user_id,
//	    identity_type
//	 )
//	 VALUES (
//	    $6::int,
//	    $7::text
//	 )
//	 RETURNING id
//	)
//	INSERT INTO password_login_identity (
//	    login_identity_id,
//	    email,
//	    phone,
//	    hashed_pass,
//	    pass_salt,
//	    verified_at
//	)
//	VALUES (
//	    (SELECT id FROM new_identity),
//	    $1::text,
//	    $2::text,
//	    $3::text,
//	    $4::text,
//	    $5::timestamptz
//	)
//	RETURNING id AS password_login_identity_id, (SELECT id AS login_identity_id FROM new_identity)
func (q *Queries) LoginIdentityCreateNewPasswordLoginIdentity(ctx context.Context, arg LoginIdentityCreateNewPasswordLoginIdentityParams) (LoginIdentityCreateNewPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityCreateNewPasswordLoginIdentity,
		arg.PasswordEmail,
		arg.PasswordPhone,
		arg.PasswordHashedPass,
		arg.PasswordPassSalt,
		arg.PasswordVerifiedAt,
		arg.IdentityUserID,
		arg.IdentityType,
	)
	var i LoginIdentityCreateNewPasswordLoginIdentityRow
	err := row.Scan(&i.PasswordLoginIdentityID, &i.LoginIdentityID)
	return i, err
}

const loginIdentityCreateNewUserAndPasswordLoginIdentity = `-- name: LoginIdentityCreateNewUserAndPasswordLoginIdentity :one
WITH new_user AS (
  INSERT INTO users (
    username,
    profile_image,
    first_name,
    last_name,
    role_id
  )
  VALUES (
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5::int
  )
  RETURNING id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id
),
new_identity AS (
  INSERT INTO login_identity (
    user_id,
    identity_type
  )
  VALUES (
    (SELECT id FROM new_user),
    $6::text
  )
  RETURNING id
),
final_insert AS (
  INSERT INTO password_login_identity (
    login_identity_id,
    email,
    phone,
    hashed_pass,
    pass_salt,
    verified_at
  )
  VALUES (
    (SELECT id FROM new_identity),
    $7::text,
    $8::text,
    $9::text,
    $10::text,
    $11::timestamptz
  )
)
SELECT id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id FROM new_user
`

type LoginIdentityCreateNewUserAndPasswordLoginIdentityParams struct {
	UserUsername       string             `json:"user_username"`
	UserProfileImage   pgtype.Text        `json:"user_profile_image"`
	UserFirstName      string             `json:"user_first_name"`
	UserLastName       pgtype.Text        `json:"user_last_name"`
	UserRoleID         pgtype.Int4        `json:"user_role_id"`
	IdentityType       string             `json:"identity_type"`
	PasswordEmail      pgtype.Text        `json:"password_email"`
	PasswordPhone      pgtype.Text        `json:"password_phone"`
	PasswordHashedPass string             `json:"password_hashed_pass"`
	PasswordPassSalt   string             `json:"password_pass_salt"`
	PasswordVerifiedAt pgtype.Timestamptz `json:"password_verified_at"`
}

type LoginIdentityCreateNewUserAndPasswordLoginIdentityRow struct {
	ID           int32              `json:"id"`
	Username     string             `json:"username"`
	ProfileImage pgtype.Text        `json:"profile_image"`
	FirstName    string             `json:"first_name"`
	MiddleName   pgtype.Text        `json:"middle_name"`
	LastName     pgtype.Text        `json:"last_name"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	BlockedAt    pgtype.Timestamptz `json:"blocked_at"`
	BlockedUntil pgtype.Timestamptz `json:"blocked_until"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	RoleID       pgtype.Int4        `json:"role_id"`
}

// LoginIdentityCreateNewUserAndPasswordLoginIdentity
//
//	WITH new_user AS (
//	  INSERT INTO users (
//	    username,
//	    profile_image,
//	    first_name,
//	    last_name,
//	    role_id
//	  )
//	  VALUES (
//	    $1::text,
//	    $2::text,
//	    $3::text,
//	    $4::text,
//	    $5::int
//	  )
//	  RETURNING id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id
//	),
//	new_identity AS (
//	  INSERT INTO login_identity (
//	    user_id,
//	    identity_type
//	  )
//	  VALUES (
//	    (SELECT id FROM new_user),
//	    $6::text
//	  )
//	  RETURNING id
//	),
//	final_insert AS (
//	  INSERT INTO password_login_identity (
//	    login_identity_id,
//	    email,
//	    phone,
//	    hashed_pass,
//	    pass_salt,
//	    verified_at
//	  )
//	  VALUES (
//	    (SELECT id FROM new_identity),
//	    $7::text,
//	    $8::text,
//	    $9::text,
//	    $10::text,
//	    $11::timestamptz
//	  )
//	)
//	SELECT id, username, profile_image, first_name, middle_name, last_name, created_at, updated_at, blocked_at, blocked_until, deleted_at, role_id FROM new_user
func (q *Queries) LoginIdentityCreateNewUserAndPasswordLoginIdentity(ctx context.Context, arg LoginIdentityCreateNewUserAndPasswordLoginIdentityParams) (LoginIdentityCreateNewUserAndPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityCreateNewUserAndPasswordLoginIdentity,
		arg.UserUsername,
		arg.UserProfileImage,
		arg.UserFirstName,
		arg.UserLastName,
		arg.UserRoleID,
		arg.IdentityType,
		arg.PasswordEmail,
		arg.PasswordPhone,
		arg.PasswordHashedPass,
		arg.PasswordPassSalt,
		arg.PasswordVerifiedAt,
	)
	var i LoginIdentityCreateNewUserAndPasswordLoginIdentityRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ProfileImage,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BlockedAt,
		&i.BlockedUntil,
		&i.DeletedAt,
		&i.RoleID,
	)
	return i, err
}

const loginIdentityGetAllByUserId = `-- name: LoginIdentityGetAllByUserId :many
SELECT
  li.id AS login_identity_id,
  li.user_id AS login_identity_user_id,
  li.identity_type AS login_identity_identity_type,
  li.is_primary AS login_identity_is_primary,
  li.last_used_at AS login_identity_last_used_at,

  -- Password-based
  pli.id AS password_id,
  pli.email  AS password_email,
  pli.phone  AS password_phone,
  pli.hashed_pass  AS password_hashed_pass,
  pli.pass_salt  AS password_pass_salt,
  pli.verified_at AS password_verified_at,

  -- Guest-based
  gli.id AS guest_id,
  gli.device_id AS guest_device_id,

  -- OIDC-based
  oidc_data.id AS oidc_data_id,
  oidc_data.sub AS oidc_data_sub,
  oidc_data.email AS oidc_data_email,
  oidc_data.iss AS oidc_data_issuer,
  oidc_data.aud AS oidc_data_audience,
  oidc_data.given_name AS oidc_data_given_name,
  oidc_data.family_name AS oidc_data_family_name,
  oidc_data.name AS oidc_data_name,
  oidc_data.picture AS oidc_data_picture,
  oidc_data.provider_name AS oauth_provider_name

FROM active_login_identity AS li
LEFT JOIN active_password_login_identity AS pli
  ON li.id = pli.login_identity_id
LEFT JOIN active_guest_login_identity AS gli
  ON li.id = gli.login_identity_id
LEFT JOIN active_oidc_login_identity AS oli
  ON li.id = oli.login_identity_id
LEFT JOIN active_oidc_data AS oidc_data
  ON oli.oidc_data_id = oidc_data.id

WHERE li.user_id = $1
ORDER BY li.is_primary DESC, li.last_used_at DESC
`

type LoginIdentityGetAllByUserIdRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	LoginIdentityUserID       int32              `json:"login_identity_user_id"`
	LoginIdentityIdentityType string             `json:"login_identity_identity_type"`
	LoginIdentityIsPrimary    pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt   pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordID                pgtype.Int4        `json:"password_id"`
	PasswordEmail             pgtype.Text        `json:"password_email"`
	PasswordPhone             pgtype.Text        `json:"password_phone"`
	PasswordHashedPass        pgtype.Text        `json:"password_hashed_pass"`
	PasswordPassSalt          pgtype.Text        `json:"password_pass_salt"`
	PasswordVerifiedAt        pgtype.Timestamptz `json:"password_verified_at"`
	GuestID                   pgtype.Int4        `json:"guest_id"`
	GuestDeviceID             pgtype.Text        `json:"guest_device_id"`
	OidcDataID                pgtype.Int4        `json:"oidc_data_id"`
	OidcDataSub               pgtype.Text        `json:"oidc_data_sub"`
	OidcDataEmail             pgtype.Text        `json:"oidc_data_email"`
	OidcDataIssuer            pgtype.Text        `json:"oidc_data_issuer"`
	OidcDataAudience          pgtype.Text        `json:"oidc_data_audience"`
	OidcDataGivenName         pgtype.Text        `json:"oidc_data_given_name"`
	OidcDataFamilyName        pgtype.Text        `json:"oidc_data_family_name"`
	OidcDataName              pgtype.Text        `json:"oidc_data_name"`
	OidcDataPicture           pgtype.Text        `json:"oidc_data_picture"`
	OauthProviderName         pgtype.Text        `json:"oauth_provider_name"`
}

// LoginIdentityGetAllByUserId
//
//	SELECT
//	  li.id AS login_identity_id,
//	  li.user_id AS login_identity_user_id,
//	  li.identity_type AS login_identity_identity_type,
//	  li.is_primary AS login_identity_is_primary,
//	  li.last_used_at AS login_identity_last_used_at,
//
//	  -- Password-based
//	  pli.id AS password_id,
//	  pli.email  AS password_email,
//	  pli.phone  AS password_phone,
//	  pli.hashed_pass  AS password_hashed_pass,
//	  pli.pass_salt  AS password_pass_salt,
//	  pli.verified_at AS password_verified_at,
//
//	  -- Guest-based
//	  gli.id AS guest_id,
//	  gli.device_id AS guest_device_id,
//
//	  -- OIDC-based
//	  oidc_data.id AS oidc_data_id,
//	  oidc_data.sub AS oidc_data_sub,
//	  oidc_data.email AS oidc_data_email,
//	  oidc_data.iss AS oidc_data_issuer,
//	  oidc_data.aud AS oidc_data_audience,
//	  oidc_data.given_name AS oidc_data_given_name,
//	  oidc_data.family_name AS oidc_data_family_name,
//	  oidc_data.name AS oidc_data_name,
//	  oidc_data.picture AS oidc_data_picture,
//	  oidc_data.provider_name AS oauth_provider_name
//
//	FROM active_login_identity AS li
//	LEFT JOIN active_password_login_identity AS pli
//	  ON li.id = pli.login_identity_id
//	LEFT JOIN active_guest_login_identity AS gli
//	  ON li.id = gli.login_identity_id
//	LEFT JOIN active_oidc_login_identity AS oli
//	  ON li.id = oli.login_identity_id
//	LEFT JOIN active_oidc_data AS oidc_data
//	  ON oli.oidc_data_id = oidc_data.id
//
//	WHERE li.user_id = $1
//	ORDER BY li.is_primary DESC, li.last_used_at DESC
func (q *Queries) LoginIdentityGetAllByUserId(ctx context.Context, userID int32) ([]LoginIdentityGetAllByUserIdRow, error) {
	rows, err := q.db.Query(ctx, loginIdentityGetAllByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginIdentityGetAllByUserIdRow{}
	for rows.Next() {
		var i LoginIdentityGetAllByUserIdRow
		if err := rows.Scan(
			&i.LoginIdentityID,
			&i.LoginIdentityUserID,
			&i.LoginIdentityIdentityType,
			&i.LoginIdentityIsPrimary,
			&i.LoginIdentityLastUsedAt,
			&i.PasswordID,
			&i.PasswordEmail,
			&i.PasswordPhone,
			&i.PasswordHashedPass,
			&i.PasswordPassSalt,
			&i.PasswordVerifiedAt,
			&i.GuestID,
			&i.GuestDeviceID,
			&i.OidcDataID,
			&i.OidcDataSub,
			&i.OidcDataEmail,
			&i.OidcDataIssuer,
			&i.OidcDataAudience,
			&i.OidcDataGivenName,
			&i.OidcDataFamilyName,
			&i.OidcDataName,
			&i.OidcDataPicture,
			&i.OauthProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginIdentityGetAllPasswordLoginIdentitiesByUserId = `-- name: LoginIdentityGetAllPasswordLoginIdentitiesByUserId :many
SELECT
  li.id AS login_identity_id,
  li.user_id AS login_identity_user_id,
  li.identity_type AS login_identity_identity_type,
  li.is_primary AS login_identity_is_primary,
  li.last_used_at AS login_identity_last_used_at,

  -- Password-based
  pli.id AS password_id,
  pli.email  AS password_email,
  pli.phone  AS password_phone,
  pli.hashed_pass  AS password_hashed_pass,
  pli.pass_salt  AS password_pass_salt,
  pli.verified_at AS password_verified_at
FROM active_login_identity AS li
LEFT JOIN active_password_login_identity AS pli
  ON li.id = pli.login_identity_id
WHERE li.user_id = $1
ORDER BY li.is_primary DESC, li.last_used_at DESC
`

type LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow struct {
	LoginIdentityID           int32              `json:"login_identity_id"`
	LoginIdentityUserID       int32              `json:"login_identity_user_id"`
	LoginIdentityIdentityType string             `json:"login_identity_identity_type"`
	LoginIdentityIsPrimary    pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt   pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordID                pgtype.Int4        `json:"password_id"`
	PasswordEmail             pgtype.Text        `json:"password_email"`
	PasswordPhone             pgtype.Text        `json:"password_phone"`
	PasswordHashedPass        pgtype.Text        `json:"password_hashed_pass"`
	PasswordPassSalt          pgtype.Text        `json:"password_pass_salt"`
	PasswordVerifiedAt        pgtype.Timestamptz `json:"password_verified_at"`
}

// LoginIdentityGetAllPasswordLoginIdentitiesByUserId
//
//	SELECT
//	  li.id AS login_identity_id,
//	  li.user_id AS login_identity_user_id,
//	  li.identity_type AS login_identity_identity_type,
//	  li.is_primary AS login_identity_is_primary,
//	  li.last_used_at AS login_identity_last_used_at,
//
//	  -- Password-based
//	  pli.id AS password_id,
//	  pli.email  AS password_email,
//	  pli.phone  AS password_phone,
//	  pli.hashed_pass  AS password_hashed_pass,
//	  pli.pass_salt  AS password_pass_salt,
//	  pli.verified_at AS password_verified_at
//	FROM active_login_identity AS li
//	LEFT JOIN active_password_login_identity AS pli
//	  ON li.id = pli.login_identity_id
//	WHERE li.user_id = $1
//	ORDER BY li.is_primary DESC, li.last_used_at DESC
func (q *Queries) LoginIdentityGetAllPasswordLoginIdentitiesByUserId(ctx context.Context, userID int32) ([]LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow, error) {
	rows, err := q.db.Query(ctx, loginIdentityGetAllPasswordLoginIdentitiesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow{}
	for rows.Next() {
		var i LoginIdentityGetAllPasswordLoginIdentitiesByUserIdRow
		if err := rows.Scan(
			&i.LoginIdentityID,
			&i.LoginIdentityUserID,
			&i.LoginIdentityIdentityType,
			&i.LoginIdentityIsPrimary,
			&i.LoginIdentityLastUsedAt,
			&i.PasswordID,
			&i.PasswordEmail,
			&i.PasswordPhone,
			&i.PasswordHashedPass,
			&i.PasswordPassSalt,
			&i.PasswordVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginIdentityGetOIDCDataBySub = `-- name: LoginIdentityGetOIDCDataBySub :one
SELECT
    u.id AS user_id,
    u.username AS user_username,
    u.profile_image AS user_profile_image,
    u.first_name AS user_first_name,
    u.middle_name AS user_middle_name,
    u.last_name AS user_last_name,
    u.blocked_at AS user_blocked_at,
    u.blocked_until AS user_blocked_until,
    u.created_at AS user_created_at,
    u.updated_at AS user_updated_at,
    u.role_id as user_role_id,
    li.id AS login_identity_id,
    od.name AS oauth_provider_name,
    od.id AS oidc_data_id

from active_oidc_data AS od
JOIN active_oidc_login_identity AS oli
    ON od.id = oli.oidc_data_id
JOIN active_login_identity AS li
    ON oli.login_identity_id = li.id
JOIN not_deleted_users AS u
    ON li.user_id = u.id

WHERE od.sub = $1::text
    AND li.identity_type = 'oidc'
    AND od.provider_name = $2::text
LIMIT 1
`

type LoginIdentityGetOIDCDataBySubParams struct {
	OidcSub          string `json:"oidc_sub"`
	OidcProviderName string `json:"oidc_provider_name"`
}

type LoginIdentityGetOIDCDataBySubRow struct {
	UserID            int32              `json:"user_id"`
	UserUsername      string             `json:"user_username"`
	UserProfileImage  pgtype.Text        `json:"user_profile_image"`
	UserFirstName     string             `json:"user_first_name"`
	UserMiddleName    pgtype.Text        `json:"user_middle_name"`
	UserLastName      pgtype.Text        `json:"user_last_name"`
	UserBlockedAt     pgtype.Timestamptz `json:"user_blocked_at"`
	UserBlockedUntil  pgtype.Timestamptz `json:"user_blocked_until"`
	UserCreatedAt     pgtype.Timestamptz `json:"user_created_at"`
	UserUpdatedAt     pgtype.Timestamptz `json:"user_updated_at"`
	UserRoleID        pgtype.Int4        `json:"user_role_id"`
	LoginIdentityID   int32              `json:"login_identity_id"`
	OauthProviderName pgtype.Text        `json:"oauth_provider_name"`
	OidcDataID        int32              `json:"oidc_data_id"`
}

// LoginIdentityGetOIDCDataBySub
//
//	SELECT
//	    u.id AS user_id,
//	    u.username AS user_username,
//	    u.profile_image AS user_profile_image,
//	    u.first_name AS user_first_name,
//	    u.middle_name AS user_middle_name,
//	    u.last_name AS user_last_name,
//	    u.blocked_at AS user_blocked_at,
//	    u.blocked_until AS user_blocked_until,
//	    u.created_at AS user_created_at,
//	    u.updated_at AS user_updated_at,
//	    u.role_id as user_role_id,
//	    li.id AS login_identity_id,
//	    od.name AS oauth_provider_name,
//	    od.id AS oidc_data_id
//
//	from active_oidc_data AS od
//	JOIN active_oidc_login_identity AS oli
//	    ON od.id = oli.oidc_data_id
//	JOIN active_login_identity AS li
//	    ON oli.login_identity_id = li.id
//	JOIN not_deleted_users AS u
//	    ON li.user_id = u.id
//
//	WHERE od.sub = $1::text
//	    AND li.identity_type = 'oidc'
//	    AND od.provider_name = $2::text
//	LIMIT 1
func (q *Queries) LoginIdentityGetOIDCDataBySub(ctx context.Context, arg LoginIdentityGetOIDCDataBySubParams) (LoginIdentityGetOIDCDataBySubRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetOIDCDataBySub, arg.OidcSub, arg.OidcProviderName)
	var i LoginIdentityGetOIDCDataBySubRow
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserProfileImage,
		&i.UserFirstName,
		&i.UserMiddleName,
		&i.UserLastName,
		&i.UserBlockedAt,
		&i.UserBlockedUntil,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
		&i.UserRoleID,
		&i.LoginIdentityID,
		&i.OauthProviderName,
		&i.OidcDataID,
	)
	return i, err
}

const loginIdentityGetPasswordLoginIdentity = `-- name: LoginIdentityGetPasswordLoginIdentity :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary AS login_identity_is_primary,
    li.last_used_at AS login_identity_last_used_at,

    pli.id AS password_login_identity_id,
    pli.email ,
    pli.phone,
    pli.hashed_pass,
    pli.pass_salt,
    pli.verified_at
FROM active_login_identity AS li
    JOIN active_password_login_identity pli
        ON li.id = pli.login_identity_id
WHERE li.identity_type = $1::text
    AND (
      ($1::text = 'email' AND pli.email = $2::text)
      OR
      ($1::text = 'phone' AND pli.phone = $2::text)
    )
LIMIT 1
`

type LoginIdentityGetPasswordLoginIdentityParams struct {
	IdentityType  string `json:"identity_type"`
	IdentityValue string `json:"identity_value"`
}

type LoginIdentityGetPasswordLoginIdentityRow struct {
	LoginIdentityID         int32              `json:"login_identity_id"`
	UserID                  int32              `json:"user_id"`
	IdentityType            string             `json:"identity_type"`
	LoginIdentityIsPrimary  pgtype.Bool        `json:"login_identity_is_primary"`
	LoginIdentityLastUsedAt pgtype.Timestamptz `json:"login_identity_last_used_at"`
	PasswordLoginIdentityID int32              `json:"password_login_identity_id"`
	Email                   pgtype.Text        `json:"email"`
	Phone                   pgtype.Text        `json:"phone"`
	HashedPass              string             `json:"hashed_pass"`
	PassSalt                string             `json:"pass_salt"`
	VerifiedAt              pgtype.Timestamptz `json:"verified_at"`
}

// LoginIdentityGetPasswordLoginIdentity
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary AS login_identity_is_primary,
//	    li.last_used_at AS login_identity_last_used_at,
//
//	    pli.id AS password_login_identity_id,
//	    pli.email ,
//	    pli.phone,
//	    pli.hashed_pass,
//	    pli.pass_salt,
//	    pli.verified_at
//	FROM active_login_identity AS li
//	    JOIN active_password_login_identity pli
//	        ON li.id = pli.login_identity_id
//	WHERE li.identity_type = $1::text
//	    AND (
//	      ($1::text = 'email' AND pli.email = $2::text)
//	      OR
//	      ($1::text = 'phone' AND pli.phone = $2::text)
//	    )
//	LIMIT 1
func (q *Queries) LoginIdentityGetPasswordLoginIdentity(ctx context.Context, arg LoginIdentityGetPasswordLoginIdentityParams) (LoginIdentityGetPasswordLoginIdentityRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetPasswordLoginIdentity, arg.IdentityType, arg.IdentityValue)
	var i LoginIdentityGetPasswordLoginIdentityRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.LoginIdentityIsPrimary,
		&i.LoginIdentityLastUsedAt,
		&i.PasswordLoginIdentityID,
		&i.Email,
		&i.Phone,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
	)
	return i, err
}

const loginIdentityGetPasswordLoginIdentityWithUser = `-- name: LoginIdentityGetPasswordLoginIdentityWithUser :one
SELECT
    li.id AS login_identity_id,
    li.user_id,
    li.identity_type,
    li.is_primary,
    li.last_used_at,

    pli.id AS password_login_identity_id,
    pli.email,
    pli.phone,
    pli.hashed_pass,
    pli.pass_salt,
    pli.verified_at,

    u.id as user_id,
    u.username as user_username,
    u.profile_image as user_profile_image,
    u.first_name as user_first_name,
    u.middle_name as user_middle_name,
    u.last_name as user_last_name,
    u.blocked_at as user_blocked_at,
    u.blocked_until as user_blocked_until,
    u.role_id as user_role_id
FROM not_deleted_users AS u
    JOIN active_login_identity AS li
        ON u.id = li.user_id
    JOIN active_password_login_identity pli
        ON li.id = pli.login_identity_id
WHERE li.identity_type = $1::text
    AND (
      ($1::text = 'email' AND pli.email = $2::text)
      OR
      ($1::text = 'phone' AND pli.phone = $2::text)
    )
LIMIT 1
`

type LoginIdentityGetPasswordLoginIdentityWithUserParams struct {
	IdentityType  string `json:"identity_type"`
	IdentityValue string `json:"identity_value"`
}

type LoginIdentityGetPasswordLoginIdentityWithUserRow struct {
	LoginIdentityID         int32              `json:"login_identity_id"`
	UserID                  int32              `json:"user_id"`
	IdentityType            string             `json:"identity_type"`
	IsPrimary               pgtype.Bool        `json:"is_primary"`
	LastUsedAt              pgtype.Timestamptz `json:"last_used_at"`
	PasswordLoginIdentityID int32              `json:"password_login_identity_id"`
	Email                   pgtype.Text        `json:"email"`
	Phone                   pgtype.Text        `json:"phone"`
	HashedPass              string             `json:"hashed_pass"`
	PassSalt                string             `json:"pass_salt"`
	VerifiedAt              pgtype.Timestamptz `json:"verified_at"`
	UserID_2                int32              `json:"user_id_2"`
	UserUsername            string             `json:"user_username"`
	UserProfileImage        pgtype.Text        `json:"user_profile_image"`
	UserFirstName           string             `json:"user_first_name"`
	UserMiddleName          pgtype.Text        `json:"user_middle_name"`
	UserLastName            pgtype.Text        `json:"user_last_name"`
	UserBlockedAt           pgtype.Timestamptz `json:"user_blocked_at"`
	UserBlockedUntil        pgtype.Timestamptz `json:"user_blocked_until"`
	UserRoleID              pgtype.Int4        `json:"user_role_id"`
}

// LoginIdentityGetPasswordLoginIdentityWithUser
//
//	SELECT
//	    li.id AS login_identity_id,
//	    li.user_id,
//	    li.identity_type,
//	    li.is_primary,
//	    li.last_used_at,
//
//	    pli.id AS password_login_identity_id,
//	    pli.email,
//	    pli.phone,
//	    pli.hashed_pass,
//	    pli.pass_salt,
//	    pli.verified_at,
//
//	    u.id as user_id,
//	    u.username as user_username,
//	    u.profile_image as user_profile_image,
//	    u.first_name as user_first_name,
//	    u.middle_name as user_middle_name,
//	    u.last_name as user_last_name,
//	    u.blocked_at as user_blocked_at,
//	    u.blocked_until as user_blocked_until,
//	    u.role_id as user_role_id
//	FROM not_deleted_users AS u
//	    JOIN active_login_identity AS li
//	        ON u.id = li.user_id
//	    JOIN active_password_login_identity pli
//	        ON li.id = pli.login_identity_id
//	WHERE li.identity_type = $1::text
//	    AND (
//	      ($1::text = 'email' AND pli.email = $2::text)
//	      OR
//	      ($1::text = 'phone' AND pli.phone = $2::text)
//	    )
//	LIMIT 1
func (q *Queries) LoginIdentityGetPasswordLoginIdentityWithUser(ctx context.Context, arg LoginIdentityGetPasswordLoginIdentityWithUserParams) (LoginIdentityGetPasswordLoginIdentityWithUserRow, error) {
	row := q.db.QueryRow(ctx, loginIdentityGetPasswordLoginIdentityWithUser, arg.IdentityType, arg.IdentityValue)
	var i LoginIdentityGetPasswordLoginIdentityWithUserRow
	err := row.Scan(
		&i.LoginIdentityID,
		&i.UserID,
		&i.IdentityType,
		&i.IsPrimary,
		&i.LastUsedAt,
		&i.PasswordLoginIdentityID,
		&i.Email,
		&i.Phone,
		&i.HashedPass,
		&i.PassSalt,
		&i.VerifiedAt,
		&i.UserID_2,
		&i.UserUsername,
		&i.UserProfileImage,
		&i.UserFirstName,
		&i.UserMiddleName,
		&i.UserLastName,
		&i.UserBlockedAt,
		&i.UserBlockedUntil,
		&i.UserRoleID,
	)
	return i, err
}

const loginIdentityIsEmailUsed = `-- name: LoginIdentityIsEmailUsed :one
SELECT COUNT(*) FROM active_password_login_identity WHERE email = $1
`

// LoginIdentityIsEmailUsed
//
//	SELECT COUNT(*) FROM active_password_login_identity WHERE email = $1
func (q *Queries) LoginIdentityIsEmailUsed(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsEmailUsed, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const loginIdentityIsOidcEmailUsed = `-- name: LoginIdentityIsOidcEmailUsed :one
SELECT COUNT(*) FROM active_oidc_data WHERE email = $1
`

// LoginIdentityIsOidcEmailUsed
//
//	SELECT COUNT(*) FROM active_oidc_data WHERE email = $1
func (q *Queries) LoginIdentityIsOidcEmailUsed(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsOidcEmailUsed, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const loginIdentityIsPhoneUsed = `-- name: LoginIdentityIsPhoneUsed :one
SELECT COUNT(*) FROM active_password_login_identity WHERE phone = $1
`

// LoginIdentityIsPhoneUsed
//
//	SELECT COUNT(*) FROM active_password_login_identity WHERE phone = $1
func (q *Queries) LoginIdentityIsPhoneUsed(ctx context.Context, phone pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, loginIdentityIsPhoneUsed, phone)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const loginIdentityUpdateLastUsedAtToNow = `-- name: LoginIdentityUpdateLastUsedAtToNow :exec
UPDATE login_identity SET
last_used_at = NOW()
WHERE id = $1
`

// LoginIdentityUpdateLastUsedAtToNow
//
//	UPDATE login_identity SET
//	last_used_at = NOW()
//	WHERE id = $1
func (q *Queries) LoginIdentityUpdateLastUsedAtToNow(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, loginIdentityUpdateLastUsedAtToNow, id)
	return err
}
